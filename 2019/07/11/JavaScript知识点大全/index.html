<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.jpg?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.jpg?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.jpg?v=7.1.1">


  <link rel="mask-icon" href="/sagari-pinned-tab.jpg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.1',
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="JS高程 1.JavaScript简介 JavaScript简史 JavaScript实现 JavaScript版本   2.在HTML中使用JavaScript script元素 嵌入代码与外部文件 文档模式 noscript元素   3.基础概念 语法 关键字和保留字 变量 数据类型 操作符 语句 函数   4.变量、作用域和内存问题 基本类型和引用类型的值 执行环境及作用域 垃圾收集">
<meta name="keywords" content="JavaScript高级程序设计(第三版),深入理解ES6,你不知道的JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript知识点大全">
<meta property="og:url" content="https://leezhimeng.com/blog/2019/07/11/JavaScript知识点大全/index.html">
<meta property="og:site_name" content="Lee Jimmy&#39;s Blog">
<meta property="og:description" content="JS高程 1.JavaScript简介 JavaScript简史 JavaScript实现 JavaScript版本   2.在HTML中使用JavaScript script元素 嵌入代码与外部文件 文档模式 noscript元素   3.基础概念 语法 关键字和保留字 变量 数据类型 操作符 语句 函数   4.变量、作用域和内存问题 基本类型和引用类型的值 执行环境及作用域 垃圾收集">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-08-23T00:57:48.637Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript知识点大全">
<meta name="twitter:description" content="JS高程 1.JavaScript简介 JavaScript简史 JavaScript实现 JavaScript版本   2.在HTML中使用JavaScript script元素 嵌入代码与外部文件 文档模式 noscript元素   3.基础概念 语法 关键字和保留字 变量 数据类型 操作符 语句 函数   4.变量、作用域和内存问题 基本类型和引用类型的值 执行环境及作用域 垃圾收集">





  
  
  <link rel="canonical" href="https://leezhimeng.com/blog/2019/07/11/JavaScript知识点大全/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>JavaScript知识点大全 | Lee Jimmy's Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Lee Jimmy's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">56</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">15</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">45</span></a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leezhimeng.com/blog/2019/07/11/JavaScript知识点大全/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李智猛">
      <meta itemprop="description" content="李智猛的个人博客">
      <meta itemprop="image" content="/images/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lee Jimmy's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JavaScript知识点大全

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-11 11:51:46" itemprop="dateCreated datePublished" datetime="2019-07-11T11:51:46+08:00">2019-07-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-23 08:57:48" itemprop="dateModified" datetime="2019-08-23T08:57:48+08:00">2019-08-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <ul>
<li><a href="#js%e9%ab%98%e7%a8%8b">JS高程</a><ul>
<li><a href="#1javascript%e7%ae%80%e4%bb%8b">1.JavaScript简介</a><ul>
<li><a href="#javascript%e7%ae%80%e5%8f%b2">JavaScript简史</a></li>
<li><a href="#javascript%e5%ae%9e%e7%8e%b0">JavaScript实现</a></li>
<li><a href="#javascript%e7%89%88%e6%9c%ac">JavaScript版本</a></li>
</ul>
</li>
<li><a href="#2%e5%9c%a8html%e4%b8%ad%e4%bd%bf%e7%94%a8javascript">2.在HTML中使用JavaScript</a><ul>
<li><a href="#script%e5%85%83%e7%b4%a0">script元素</a></li>
<li><a href="#%e5%b5%8c%e5%85%a5%e4%bb%a3%e7%a0%81%e4%b8%8e%e5%a4%96%e9%83%a8%e6%96%87%e4%bb%b6">嵌入代码与外部文件</a></li>
<li><a href="#%e6%96%87%e6%a1%a3%e6%a8%a1%e5%bc%8f">文档模式</a></li>
<li><a href="#noscript%e5%85%83%e7%b4%a0">noscript元素</a></li>
</ul>
</li>
<li><a href="#3%e5%9f%ba%e7%a1%80%e6%a6%82%e5%bf%b5">3.基础概念</a><ul>
<li><a href="#%e8%af%ad%e6%b3%95">语法</a></li>
<li><a href="#%e5%85%b3%e9%94%ae%e5%ad%97%e5%92%8c%e4%bf%9d%e7%95%99%e5%ad%97">关键字和保留字</a></li>
<li><a href="#%e5%8f%98%e9%87%8f">变量</a></li>
<li><a href="#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b">数据类型</a></li>
<li><a href="#%e6%93%8d%e4%bd%9c%e7%ac%a6">操作符</a></li>
<li><a href="#%e8%af%ad%e5%8f%a5">语句</a></li>
<li><a href="#%e5%87%bd%e6%95%b0">函数</a></li>
</ul>
</li>
<li><a href="#4%e5%8f%98%e9%87%8f%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%92%8c%e5%86%85%e5%ad%98%e9%97%ae%e9%a2%98">4.变量、作用域和内存问题</a><ul>
<li><a href="#%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b%e5%92%8c%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%80%bc">基本类型和引用类型的值</a></li>
<li><a href="#%e6%89%a7%e8%a1%8c%e7%8e%af%e5%a2%83%e5%8f%8a%e4%bd%9c%e7%94%a8%e5%9f%9f">执行环境及作用域</a></li>
<li><a href="#%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86">垃圾收集</a></li>
</ul>
</li>
<li><a href="#5%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b">5.引用类型</a><ul>
<li><a href="#object%e7%b1%bb%e5%9e%8b">Object类型</a></li>
<li><a href="#array%e7%b1%bb%e5%9e%8b">Array类型</a></li>
<li><a href="#date%e7%b1%bb%e5%9e%8b">Date类型</a></li>
<li><a href="#regexp%e7%b1%bb%e5%9e%8b">RegExp类型</a></li>
<li><a href="#function%e7%b1%bb%e5%9e%8b">Function类型</a></li>
<li><a href="#%e5%9f%ba%e6%9c%ac%e5%8c%85%e8%a3%85%e7%b1%bb%e5%9e%8b">基本包装类型</a></li>
<li><a href="#%e5%8d%95%e4%bd%93%e5%86%85%e7%bd%ae%e5%af%b9%e8%b1%a1">单体内置对象</a></li>
</ul>
</li>
<li><a href="#6%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1">6.面向对象的程序设计</a><ul>
<li><a href="#%e7%90%86%e8%a7%a3%e5%af%b9%e8%b1%a1">理解对象</a></li>
<li><a href="#%e5%88%9b%e5%bb%ba%e5%af%b9%e8%b1%a1">创建对象</a></li>
<li><a href="#%e7%bb%a7%e6%89%bf">继承</a></li>
</ul>
</li>
<li><a href="#7%e5%87%bd%e6%95%b0%e8%a1%a8%e8%be%be%e5%bc%8f">7.函数表达式</a><ul>
<li><a href="#%e9%80%92%e5%bd%92">递归</a></li>
<li><a href="#%e9%97%ad%e5%8c%85">闭包</a></li>
<li><a href="#%e6%a8%a1%e4%bb%bf%e5%9d%97%e7%ba%a7%e4%bd%9c%e7%94%a8%e5%9f%9f">模仿块级作用域</a></li>
<li><a href="#%e7%a7%81%e6%9c%89%e5%8f%98%e9%87%8f">私有变量</a></li>
</ul>
</li>
<li><a href="#8bom">8.BOM</a><ul>
<li><a href="#window%e5%af%b9%e8%b1%a1">Window对象</a></li>
<li><a href="#location%e5%af%b9%e8%b1%a1">location对象</a></li>
<li><a href="#navigator%e5%af%b9%e8%b1%a1">navigator对象</a></li>
<li><a href="#screen%e5%af%b9%e8%b1%a1">screen对象</a></li>
<li><a href="#history%e5%af%b9%e8%b1%a1">history对象</a></li>
</ul>
</li>
<li><a href="#9%e5%ae%a2%e6%88%b7%e7%ab%af%e6%a3%80%e6%b5%8b%e6%a3%80%e6%b5%8b%e6%98%af%e5%95%a5%e6%b5%8f%e8%a7%88%e5%99%a8">9.客户端检测(检测是啥浏览器)</a><ul>
<li><a href="#%e8%83%bd%e5%8a%9b%e7%9b%91%e6%b5%8b">能力监测</a></li>
<li><a href="#%e6%80%aa%e7%99%96%e6%a3%80%e6%b5%8b">怪癖检测</a></li>
<li><a href="#%e7%94%a8%e6%88%b7%e4%bb%a3%e7%90%86%e6%a3%80%e6%b5%8b">用户代理检测</a></li>
</ul>
</li>
<li><a href="#10dom">10.DOM</a><ul>
<li><a href="#%e8%8a%82%e7%82%b9%e5%b1%82%e6%ac%a1">节点层次</a></li>
<li><a href="#dom%e6%93%8d%e4%bd%9c%e6%8a%80%e6%9c%af">DOM操作技术</a></li>
</ul>
</li>
<li><a href="#11dom%e6%8b%93%e5%b1%95">11.DOM拓展</a><ul>
<li><a href="#%e9%80%89%e6%8b%a9%e7%ac%a6api">选择符API</a></li>
<li><a href="#%e5%85%83%e7%b4%a0%e9%81%8d%e5%8e%86">元素遍历</a></li>
<li><a href="#html5">HTML5</a></li>
<li><a href="#%e4%b8%93%e6%9c%89%e6%89%a9%e5%b1%95">专有扩展</a></li>
</ul>
</li>
<li><a href="#12dom2%e5%92%8cdom3">12.DOM2和DOM3</a><ul>
<li><a href="#dom%e5%8f%98%e5%8c%96">DOM变化</a></li>
<li><a href="#%e6%a0%b7%e5%bc%8f">样式</a></li>
<li><a href="#%e9%81%8d%e5%8e%86">遍历</a></li>
<li><a href="#%e8%8c%83%e5%9b%b4">范围</a></li>
</ul>
</li>
<li><a href="#13%e4%ba%8b%e4%bb%b6">13.事件</a><ul>
<li><a href="#%e4%ba%8b%e4%bb%b6%e6%b5%81">事件流</a></li>
<li><a href="#%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86%e7%a8%8b%e5%ba%8f">事件处理程序</a></li>
<li><a href="#%e4%ba%8b%e4%bb%b6%e5%af%b9%e8%b1%a1">事件对象</a></li>
<li><a href="#%e4%ba%8b%e4%bb%b6%e7%b1%bb%e5%9e%8b">事件类型</a></li>
<li><a href="#%e5%86%85%e5%ad%98%e5%92%8c%e6%80%a7%e8%83%bd">内存和性能</a></li>
<li><a href="#%e6%a8%a1%e6%8b%9f%e4%ba%8b%e4%bb%b6">模拟事件</a></li>
</ul>
</li>
<li><a href="#20json">20.Json</a><ul>
<li><a href="#%e8%af%ad%e6%b3%95-1">语法</a><ul>
<li><a href="#%e7%ae%80%e5%8d%95%e5%80%bc">简单值</a></li>
<li><a href="#%e5%af%b9%e8%b1%a1">对象</a></li>
<li><a href="#%e6%95%b0%e7%bb%84">数组</a></li>
</ul>
</li>
<li><a href="#%e8%a7%a3%e6%9e%90%e4%b8%8e%e5%ba%8f%e5%88%97%e5%8c%96">解析与序列化</a><ul>
<li><a href="#json%e5%af%b9%e8%b1%a1">JSON对象</a></li>
<li><a href="#%e5%ba%8f%e5%88%97%e5%8c%96%e9%80%89%e9%a1%b9">序列化选项</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#21ajax%e4%b8%8ecomet">21.Ajax与Comet</a><ul>
<li><a href="#xmlhttprequest%e5%af%b9%e8%b1%a1">XMLHttpRequest对象</a></li>
<li><a href="#xmlhttprequest-2%e7%ba%a7">XMLHttpRequest 2级</a></li>
<li><a href="#%e8%bf%9b%e5%ba%a6%e4%ba%8b%e4%bb%b6">进度事件</a></li>
<li><a href="#%e8%b7%a8%e5%9f%9f%e8%b5%84%e6%ba%90%e5%85%b1%e4%ba%ab">跨域资源共享</a></li>
<li><a href="#%e5%85%b6%e4%bb%96%e8%b7%a8%e5%9f%9f%e6%8a%80%e6%9c%af">其他跨域技术</a></li>
<li><a href="#%e5%ae%89%e5%85%a8">安全</a></li>
</ul>
</li>
<li><a href="#22%e9%ab%98%e7%ba%a7%e6%8a%80%e5%b7%a7">22.高级技巧</a><ul>
<li><a href="#%e9%ab%98%e7%ba%a7%e5%87%bd%e6%95%b0">高级函数</a></li>
<li><a href="#%e9%98%b2%e7%af%a1%e6%94%b9%e5%af%b9%e8%b1%a1">防篡改对象</a></li>
<li><a href="#%e9%ab%98%e7%ba%a7%e5%ae%9a%e6%97%b6%e5%99%a8">高级定时器</a></li>
<li><a href="#%e8%87%aa%e5%ae%9a%e4%b9%89%e4%ba%8b%e4%bb%b6">自定义事件</a></li>
<li><a href="#%e6%8b%96%e6%94%be">拖放</a></li>
</ul>
</li>
<li><a href="#23%e7%a6%bb%e7%ba%bf%e5%ba%94%e7%94%a8%e4%b8%8e%e5%ae%a2%e6%88%b7%e7%ab%af%e5%ad%98%e5%82%a8">23.离线应用与客户端存储</a><ul>
<li><a href="#%e7%a6%bb%e7%ba%bf%e7%9b%91%e6%b5%8b">离线监测</a></li>
<li><a href="#%e5%ba%94%e7%94%a8%e7%bc%93%e5%ad%98">应用缓存</a></li>
<li><a href="#%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8">数据存储</a></li>
</ul>
</li>
<li><a href="#24%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5">24.最佳实践</a><ul>
<li><a href="#%e5%8f%af%e7%bb%b4%e6%8a%a4%e6%80%a7">可维护性</a></li>
<li><a href="#%e6%80%a7%e8%83%bd">性能</a></li>
<li><a href="#%e9%83%a8%e7%bd%b2">部署</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#es6">ES6</a><ul>
<li><a href="#symbol%e5%92%8csymbol%e5%b1%9e%e6%80%a7">Symbol和Symbol属性</a><ul>
<li><a href="#%e5%88%9b%e5%bb%basymbol">创建Symbol</a></li>
<li><a href="#symbol%e7%9a%84%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95">Symbol的使用方法</a></li>
<li><a href="#symbol%e5%85%b1%e4%ba%ab%e4%bd%93%e7%b3%bb">Symbol共享体系</a></li>
<li><a href="#symbol%e4%b8%8e%e7%b1%bb%e5%9e%8b%e5%bc%ba%e5%88%b6%e8%bd%ac%e6%8d%a2">Symbol与类型强制转换</a></li>
<li><a href="#symbol%e5%b1%9e%e6%80%a7%e6%a3%80%e7%b4%a2">Symbol属性检索</a></li>
<li><a href="#%e9%80%9a%e8%bf%87">通过</a></li>
</ul>
</li>
<li><a href="#7set%e9%9b%86%e5%90%88%e5%92%8cmap%e9%9b%86%e5%90%88">7.Set集合和Map集合</a><ul>
<li><a href="#es5%e4%b8%ad%e7%9a%84set%e9%9b%86%e5%90%88%e5%92%8cmap%e9%9b%86%e5%90%88">ES5中的Set集合和Map集合</a></li>
<li><a href="#es6%e4%b8%ad%e7%9a%84set%e9%9b%86%e5%90%88">ES6中的Set集合</a></li>
<li><a href="#weak-set%e9%9b%86%e5%90%88">Weak Set集合</a></li>
<li><a href="#es6%e4%b8%ad%e7%9a%84map%e9%9b%86%e5%90%88">ES6中的Map集合</a></li>
<li><a href="#weak-map%e9%9b%86%e5%90%88">Weak Map集合</a></li>
</ul>
</li>
<li><a href="#8%e8%bf%ad%e4%bb%a3%e5%99%a8iterator%e5%92%8c%e7%94%9f%e6%88%90%e5%99%a8generator">8.迭代器(Iterator)和生成器(Generator)</a><ul>
<li><a href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%bf%ad%e4%bb%a3%e5%99%a8">什么是迭代器</a></li>
<li><a href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%94%9f%e6%88%90%e5%99%a8">什么是生成器</a></li>
<li><a href="#%e5%8f%af%e8%bf%ad%e4%bb%a3%e5%af%b9%e8%b1%a1%e5%92%8cfor-of%e5%be%aa%e7%8e%af">可迭代对象和for-of循环</a></li>
<li><a href="#%e5%86%85%e5%bb%ba%e8%bf%ad%e4%bb%a3%e5%99%a8">内建迭代器</a></li>
<li><a href="#%e5%b1%95%e5%bc%80%e8%bf%90%e7%ae%97%e7%ac%a6%e4%b8%8e%e9%9d%9e%e6%95%b0%e7%bb%84%e5%8f%af%e8%bf%ad%e4%bb%a3%e5%af%b9%e8%b1%a1">展开运算符与非数组可迭代对象</a></li>
<li><a href="#%e9%ab%98%e7%ba%a7%e8%bf%ad%e4%bb%a3%e5%99%a8%e5%8a%9f%e8%83%bd">高级迭代器功能</a></li>
<li><a href="#%e5%bc%82%e6%ad%a5%e4%bb%bb%e5%8a%a1%e6%89%a7%e8%a1%8c">异步任务执行</a></li>
</ul>
</li>
<li><a href="#9javascript%e4%b8%ad%e7%9a%84%e7%b1%bb">9.JavaScript中的类</a><ul>
<li><a href="#es5%e4%b8%ad%e7%9a%84%e8%bf%91%e7%b1%bb%e7%bb%93%e6%9e%84">ES5中的近类结构</a></li>
<li><a href="#%e7%b1%bb%e7%9a%84%e5%a3%b0%e6%98%8e">类的声明</a></li>
<li><a href="#%e7%b1%bb%e8%a1%a8%e8%be%be%e5%bc%8f">类表达式</a></li>
<li><a href="#%e4%bd%9c%e4%b8%ba%e4%b8%80%e7%ad%89%e5%85%ac%e6%b0%91%e7%9a%84%e7%b1%bb">作为一等公民的类</a></li>
<li><a href="#%e8%ae%bf%e9%97%ae%e5%99%a8%e5%b1%9e%e6%80%a7">访问器属性</a></li>
<li><a href="#%e5%8f%af%e8%ae%a1%e7%ae%97%e6%88%90%e5%91%98%e5%90%8d%e7%a7%b0">可计算成员名称</a></li>
<li><a href="#%e7%94%9f%e6%88%90%e5%99%a8%e6%96%b9%e6%b3%95">生成器方法</a></li>
<li><a href="#%e9%9d%99%e6%80%81%e6%88%90%e5%91%98">静态成员</a></li>
<li><a href="#%e7%bb%a7%e6%89%bf%e4%b8%8e%e6%b4%be%e7%94%9f%e7%b1%bb">继承与派生类</a></li>
<li><a href="#%e5%9c%a8%e7%b1%bb%e7%9a%84%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e4%b8%ad%e4%bd%bf%e7%94%a8newtarget">在类的构造函数中使用new.target</a></li>
</ul>
</li>
<li><a href="#10%e6%94%b9%e8%bf%9b%e7%9a%84%e6%95%b0%e7%bb%84%e5%8a%9f%e8%83%bd">10.改进的数组功能</a><ul>
<li><a href="#%e5%88%9b%e5%bb%ba%e6%95%b0%e7%bb%84">创建数组</a></li>
<li><a href="#es6%e6%95%b0%e7%bb%84%e6%96%b0%e6%96%b9%e6%b3%95">ES6数组新方法</a></li>
<li><a href="#%e5%ae%9a%e5%9e%8b%e6%95%b0%e7%bb%84">定型数组</a></li>
<li><a href="#%e5%ae%9a%e5%9e%8b%e6%95%b0%e7%bb%84%e4%b8%8e%e6%99%ae%e9%80%9a%e6%95%b0%e7%bb%84%e6%af%94%e8%be%83">定型数组与普通数组比较</a><ul>
<li><a href="#%e7%9b%b8%e4%bc%bc%e4%b9%8b%e5%a4%84">相似之处</a></li>
<li><a href="#%e5%b7%ae%e5%88%ab">差别</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#11promise%e4%b8%8e%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b">11.Promise与异步编程</a><ul>
<li><a href="#%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b">异步编程</a></li>
<li><a href="#promise%e5%9f%ba%e7%a1%80">Promise基础</a></li>
<li><a href="#%e5%85%a8%e5%b1%80%e7%9a%84promise%e6%8b%92%e7%bb%9d%e5%a4%84%e7%90%86">全局的Promise拒绝处理</a></li>
<li><a href="#%e4%b8%b2%e8%81%94promise">串联Promise</a></li>
<li><a href="#%e5%93%8d%e5%ba%94%e5%a4%9a%e4%b8%aapromise">响应多个Promise</a></li>
<li><a href="#%e8%87%aapromise%e7%bb%a7%e6%89%bf">自Promise继承</a></li>
<li><a href="#%e5%9f%ba%e4%ba%8epromise%e7%9a%84%e5%bc%82%e6%ad%a5%e4%bb%bb%e5%8a%a1%e6%89%a7%e8%a1%8c">基于Promise的异步任务执行</a></li>
</ul>
</li>
<li><a href="#13%e7%94%a8%e6%a8%a1%e5%9d%97%e5%b0%81%e8%a3%85%e4%bb%a3%e7%a0%81">13.用模块封装代码</a><ul>
<li><a href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%a8%a1%e5%9d%97">什么是模块</a></li>
<li><a href="#%e5%af%bc%e5%87%ba%e7%9a%84%e5%9f%ba%e6%9c%ac%e8%af%ad%e6%b3%95">导出的基本语法</a></li>
<li><a href="#%e5%af%bc%e5%85%a5%e7%9a%84%e5%9f%ba%e6%9c%ac%e8%af%ad%e6%b3%95">导入的基本语法</a></li>
<li><a href="#%e5%af%bc%e5%87%ba%e5%92%8c%e5%af%bc%e5%85%a5%e6%97%b6%e9%87%8d%e5%91%bd%e5%90%8d">导出和导入时重命名</a></li>
<li><a href="#%e6%a8%a1%e5%9d%97%e7%9a%84%e9%bb%98%e8%ae%a4%e5%80%bc">模块的默认值</a></li>
<li><a href="#%e9%87%8d%e6%96%b0%e5%af%bc%e5%87%ba%e4%b8%80%e4%b8%aa%e7%bb%91%e5%ae%9a">重新导出一个绑定</a></li>
<li><a href="#%e6%97%a0%e7%bb%91%e5%ae%9a%e5%af%bc%e5%85%a5">无绑定导入</a></li>
<li><a href="#%e5%8a%a0%e8%bd%bd%e6%a8%a1%e5%9d%97">加载模块</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%e4%bd%a0%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84js">你不知道的JS</a><ul>
<li><a href="#%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%92%8c%e9%97%ad%e5%8c%85">作用域和闭包</a><ul>
<li><a href="#%e4%bd%9c%e7%94%a8%e5%9f%9f%e6%98%af%e4%bb%80%e4%b9%88">作用域是什么</a><ul>
<li><a href="#%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86">编译原理</a></li>
<li><a href="#%e7%90%86%e8%a7%a3%e4%bd%9c%e7%94%a8%e5%9f%9f">理解作用域</a></li>
<li><a href="#%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%b5%8c%e5%a5%97">作用域嵌套</a></li>
<li><a href="#%e5%bc%82%e5%b8%b8">异常</a></li>
</ul>
</li>
<li><a href="#%e8%af%8d%e6%b3%95%e4%bd%9c%e7%94%a8%e5%9f%9f">词法作用域</a><ul>
<li><a href="#%e8%af%8d%e6%b3%95%e9%98%b6%e6%ae%b5">词法阶段</a></li>
<li><a href="#%e6%ac%ba%e9%aa%97%e8%af%8d%e6%b3%95">欺骗词法</a></li>
<li><a href="#%e6%80%a7%e8%83%bd-1">性能</a></li>
</ul>
</li>
<li><a href="#%e5%87%bd%e6%95%b0%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%92%8c%e5%9d%97%e4%bd%9c%e7%94%a8%e5%9f%9f">函数作用域和块作用域</a><ul>
<li><a href="#%e5%87%bd%e6%95%b0%e4%b8%ad%e7%9a%84%e4%bd%9c%e7%94%a8%e5%9f%9f">函数中的作用域</a></li>
<li><a href="#%e9%9a%90%e8%97%8f%e5%86%85%e9%83%a8%e5%ae%9e%e7%8e%b0">隐藏内部实现</a></li>
<li><a href="#%e5%87%bd%e6%95%b0%e4%bd%9c%e7%94%a8%e5%9f%9f">函数作用域</a></li>
<li><a href="#%e5%9d%97%e4%bd%9c%e7%94%a8%e5%9f%9f">块作用域</a></li>
</ul>
</li>
<li><a href="#%e6%8f%90%e5%8d%87">提升</a><ul>
<li><a href="#%e5%8f%98%e9%87%8f%e5%a3%b0%e6%98%8e%e6%8f%90%e5%8d%87%e5%92%8c%e5%87%bd%e6%95%b0%e5%a3%b0%e6%98%8e%e6%8f%90%e5%8d%87">变量声明提升和函数声明提升</a></li>
<li><a href="#%e7%bc%96%e8%af%91%e5%99%a8%e5%a4%84%e7%90%86%e6%8f%90%e5%8d%87">编译器处理提升</a></li>
<li><a href="#%e5%87%bd%e6%95%b0%e4%bc%98%e5%85%88">函数优先</a></li>
</ul>
</li>
<li><a href="#%e4%bd%9c%e7%94%a8%e5%9f%9f%e9%97%ad%e5%8c%85">作用域闭包</a><ul>
<li><a href="#%e5%ae%9e%e8%b4%a8%e9%97%ae%e9%a2%98">实质问题</a></li>
<li><a href="#%e5%be%aa%e7%8e%af%e5%92%8c%e9%97%ad%e5%8c%85">循环和闭包</a></li>
<li><a href="#%e6%a8%a1%e5%9d%97">模块</a></li>
</ul>
</li>
<li><a href="#%e9%99%84%e5%bd%95">附录</a><ul>
<li><a href="#%e5%8a%a8%e6%80%81%e4%bd%9c%e7%94%a8%e5%9f%9f">动态作用域</a></li>
<li><a href="#%e5%9d%97%e7%ba%a7%e4%bd%9c%e7%94%a8%e5%9f%9f%e7%9a%84%e6%9b%bf%e4%bb%a3%e6%96%b9%e6%a1%88">块级作用域的替代方案</a></li>
<li><a href="#this%e8%af%8d%e6%b3%95">this词法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#this%e5%92%8c%e5%af%b9%e8%b1%a1%e5%8e%9f%e5%9e%8b">this和对象原型</a><ul>
<li><a href="#%e5%85%b3%e4%ba%8ethis">关于this</a><ul>
<li><a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8this">为什么要用this</a></li>
<li><a href="#%e8%af%af%e8%a7%a3">误解</a></li>
<li><a href="#this%e5%88%b0%e5%ba%95%e6%98%af%e4%bb%80%e4%b9%88">this到底是什么</a></li>
</ul>
</li>
<li><a href="#this%e5%85%a8%e9%9d%a2%e8%a7%a3%e6%9e%90">this全面解析</a><ul>
<li><a href="#%e8%b0%83%e7%94%a8%e4%bd%8d%e7%bd%ae">调用位置</a></li>
<li><a href="#%e7%bb%91%e5%ae%9a%e8%a7%84%e5%88%99">绑定规则</a></li>
<li><a href="#%e4%bc%98%e5%85%88%e7%ba%a7">优先级</a></li>
<li><a href="#%e7%bb%91%e5%ae%9a%e4%be%8b%e5%a4%96">绑定例外</a></li>
<li><a href="#%e9%87%8d%e6%8f%90this%e8%af%8d%e6%b3%95">重提this词法</a></li>
</ul>
</li>
<li><a href="#%e5%af%b9%e8%b1%a1-1">对象</a><ul>
<li><a href="#%e5%af%b9%e8%b1%a1%e8%af%ad%e6%b3%95">对象语法</a></li>
<li><a href="#%e5%af%b9%e8%b1%a1%e7%b1%bb%e5%9e%8b">对象类型</a></li>
<li><a href="#%e5%af%b9%e8%b1%a1%e7%9a%84%e5%86%85%e5%ae%b9">对象的内容</a></li>
<li><a href="#%e9%81%8d%e5%8e%86-1">遍历</a></li>
</ul>
</li>
<li><a href="#%e6%b7%b7%e5%90%88%e5%af%b9%e8%b1%a1%e7%b1%bb">混合对象“类”</a><ul>
<li><a href="#%e7%b1%bb%e7%90%86%e8%ae%ba">类理论</a></li>
<li><a href="#%e7%b1%bb%e7%9a%84%e6%9c%ba%e5%88%b6">类的机制</a></li>
<li><a href="#%e7%b1%bb%e7%9a%84%e7%bb%a7%e6%89%bf">类的继承</a></li>
<li><a href="#%e6%b7%b7%e5%85%a5">混入</a></li>
</ul>
</li>
<li><a href="#%e5%8e%9f%e5%9e%8b">原型</a></li>
<li><a href="#%e8%a1%8c%e4%b8%ba%e5%a7%94%e6%89%98">行为委托</a></li>
<li><a href="#es6%e4%b8%ad%e7%9a%84class">ES6中的class</a></li>
</ul>
</li>
<li><a href="#%e7%b1%bb%e5%9e%8b%e5%92%8c%e8%af%ad%e6%b3%95">类型和语法</a><ul>
<li><a href="#%e7%b1%bb%e5%9e%8b">类型</a></li>
<li><a href="#%e5%80%bc">值</a></li>
<li><a href="#%e5%8e%9f%e7%94%9f%e5%87%bd%e6%95%b0">原生函数</a></li>
<li><a href="#%e5%bc%ba%e5%88%b6%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2">强制类型转换</a></li>
<li><a href="#%e8%af%ad%e6%b3%95-2">语法</a></li>
<li><a href="#%e6%b7%b7%e5%90%88%e7%8e%af%e5%a2%83javascript">混合环境JavaScript</a></li>
</ul>
</li>
<li><a href="#%e5%bc%82%e6%ad%a5%e5%92%8c%e6%80%a7%e8%83%bd">异步和性能</a><ul>
<li><a href="#%e5%bc%82%e6%ad%a5%e7%9a%84%e7%8e%b0%e5%9c%a8%e5%92%8c%e5%b0%86%e6%9d%a5">异步的现在和将来</a><ul>
<li><a href="#%e5%88%86%e5%9d%97%e7%9a%84%e7%a8%8b%e5%ba%8f">分块的程序</a></li>
<li><a href="#%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af">事件循环</a></li>
<li><a href="#%e5%b9%b6%e8%a1%8c%e7%ba%bf%e7%a8%8b">并行线程</a></li>
<li><a href="#%e5%b9%b6%e5%8f%91">并发</a></li>
<li><a href="#%e4%bb%bb%e5%8a%a1">任务</a></li>
<li><a href="#%e8%af%ad%e5%8f%a5%e9%a1%ba%e5%ba%8f">语句顺序</a></li>
</ul>
</li>
<li><a href="#%e5%9b%9e%e8%b0%83">回调</a><ul>
<li><a href="#continuation">continuation</a></li>
<li><a href="#%e9%a1%ba%e5%ba%8f%e7%9a%84%e5%a4%a7%e8%84%91">顺序的大脑</a></li>
<li><a href="#%e4%bf%a1%e4%bb%bb%e9%97%ae%e9%a2%98">信任问题</a></li>
<li><a href="#%e7%9c%81%e7%82%b9%e5%9b%9e%e8%b0%83">省点回调</a></li>
</ul>
</li>
<li><a href="#promise">Promise</a><ul>
<li><a href="#%e4%bb%80%e4%b9%88%e6%98%afpromise">什么是Promise</a></li>
<li><a href="#%e5%85%b7%e6%9c%89then%e6%96%b9%e6%b3%95%e7%9a%84%e9%b8%ad%e5%ad%90%e7%b1%bb%e5%9e%8b">具有then方法的鸭子类型</a></li>
<li><a href="#promise%e4%bf%a1%e4%bb%bb%e9%97%ae%e9%a2%98">Promise信任问题</a></li>
<li><a href="#%e9%93%be%e5%bc%8f%e6%b5%81">链式流</a></li>
<li><a href="#%e9%94%99%e8%af%af%e5%a4%84%e7%90%86">错误处理</a></li>
<li><a href="#promise%e6%a8%a1%e5%bc%8f">Promise模式</a></li>
<li><a href="#promsie-api%e6%a6%82%e8%bf%b0">Promsie API概述</a></li>
<li><a href="#promise%e5%b1%80%e9%99%90%e6%80%a7">Promise局限性</a></li>
</ul>
</li>
<li><a href="#%e7%94%9f%e6%88%90%e5%99%a8">生成器</a><ul>
<li><a href="#%e6%89%93%e7%a0%b4%e5%ae%8c%e6%95%b4%e8%bf%90%e8%a1%8c">打破完整运行</a></li>
<li><a href="#%e7%94%9f%e6%88%90%e5%99%a8%e4%ba%a7%e7%94%9f%e5%80%bc">生成器产生值</a></li>
<li><a href="#%e5%bc%82%e6%ad%a5%e8%bf%ad%e4%bb%a3%e7%94%9f%e6%88%90%e5%99%a8">异步迭代生成器</a></li>
<li><a href="#%e7%94%9f%e6%88%90%e5%99%a8promise">生成器+Promise</a></li>
<li><a href="#%e7%94%9f%e6%88%90%e5%99%a8%e5%a7%94%e6%89%98">生成器委托</a></li>
<li><a href="#%e7%94%9f%e6%88%90%e5%99%a8%e5%b9%b6%e5%8f%91">生成器并发</a></li>
<li><a href="#%e5%bd%a2%e5%ae%9e%e8%bd%ac%e6%8d%a2%e7%a8%8b%e5%ba%8f">形实转换程序</a></li>
<li><a href="#es6%e4%b9%8b%e5%89%8d%e7%9a%84%e7%94%9f%e6%88%90%e5%99%a8">ES6之前的生成器</a></li>
</ul>
</li>
<li><a href="#%e7%a8%8b%e5%ba%8f%e6%80%a7%e8%83%bd">程序性能</a></li>
<li><a href="#%e6%80%a7%e8%83%bd%e6%b5%8b%e8%af%95%e4%b8%8e%e8%b0%83%e4%bc%98">性能测试与调优</a></li>
<li><a href="#asynquence%e5%ba%93">asynquence库</a></li>
<li><a href="#%e9%ab%98%e7%ba%a7%e5%bc%82%e6%ad%a5%e6%a8%a1%e5%bc%8f">高级异步模式</a></li>
</ul>
</li>
<li><a href="#%e8%b5%b7%e6%ad%a5%e4%b8%8a%e8%b7%af">起步上路</a><ul>
<li><a href="#%e6%b7%b1%e5%85%a5%e7%bc%96%e7%a8%8b">深入编程</a></li>
<li><a href="#%e6%b7%b1%e5%85%a5javascript">深入JavaScript</a></li>
</ul>
</li>
<li><a href="#es6%e5%8f%8a%e6%9b%b4%e6%96%b0%e7%89%88%e6%9c%ac">ES6及更新版本</a><ul>
<li><a href="#es%e7%9a%84%e7%8e%b0%e5%9c%a8%e4%b8%8e%e6%9c%aa%e6%9d%a5">ES的现在与未来</a></li>
<li><a href="#es6%e8%af%ad%e6%b3%95">ES6语法</a></li>
<li><a href="#%e4%bb%a3%e7%a0%81%e7%bb%84%e7%bb%87">代码组织</a></li>
<li><a href="#%e5%bc%82%e6%ad%a5%e6%b5%81%e6%8e%a7%e5%88%b6">异步流控制</a></li>
<li><a href="#%e9%9b%86%e5%90%88">集合</a></li>
<li><a href="#%e6%96%b0%e5%a2%9eapi">新增API</a></li>
<li><a href="#%e5%85%83%e7%bc%96%e7%a8%8b">元编程</a></li>
<li><a href="#es6%e4%b9%8b%e5%90%8e">ES6之后</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="JS高程"><a href="#JS高程" class="headerlink" title="JS高程"></a>JS高程</h1><h2 id="1-JavaScript简介"><a href="#1-JavaScript简介" class="headerlink" title="1.JavaScript简介"></a>1.JavaScript简介</h2><h3 id="JavaScript简史"><a href="#JavaScript简史" class="headerlink" title="JavaScript简史"></a>JavaScript简史</h3><h3 id="JavaScript实现"><a href="#JavaScript实现" class="headerlink" title="JavaScript实现"></a>JavaScript实现</h3><ul>
<li>ES</li>
<li>DOM</li>
<li>BOM<h3 id="JavaScript版本"><a href="#JavaScript版本" class="headerlink" title="JavaScript版本"></a>JavaScript版本</h3></li>
</ul>
<h2 id="2-在HTML中使用JavaScript"><a href="#2-在HTML中使用JavaScript" class="headerlink" title="2.在HTML中使用JavaScript"></a>2.在HTML中使用JavaScript</h2><h3 id="script元素"><a href="#script元素" class="headerlink" title="script元素"></a>script元素</h3><ul>
<li>标签的位置</li>
<li>延迟脚本</li>
<li>异步脚本</li>
<li>在XHTML中的用法</li>
<li>不推荐使用的语法<h3 id="嵌入代码与外部文件"><a href="#嵌入代码与外部文件" class="headerlink" title="嵌入代码与外部文件"></a>嵌入代码与外部文件</h3><h3 id="文档模式"><a href="#文档模式" class="headerlink" title="文档模式"></a>文档模式</h3><h3 id="noscript元素"><a href="#noscript元素" class="headerlink" title="noscript元素"></a>noscript元素</h3></li>
</ul>
<h2 id="3-基础概念"><a href="#3-基础概念" class="headerlink" title="3.基础概念"></a>3.基础概念</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul>
<li><p>区分大小写</p>
</li>
<li><p>标识符</p>
</li>
<li><p>注释</p>
</li>
<li><p>严格模式</p>
</li>
<li><p>语句</p>
<h3 id="关键字和保留字"><a href="#关键字和保留字" class="headerlink" title="关键字和保留字"></a>关键字和保留字</h3><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3></li>
<li><p>typeof操作符</p>
<ul>
<li>用来检测变量的数据类型</li>
<li><code>typeof null //object</code></li>
<li><code>typeof (new RegExp())  //object,chrome7之前返回function</code></li>
<li><code>typeof()可以使用，但不必要，typeof是操作符不是函数</code></li>
</ul>
</li>
<li><p>Undefined类型</p>
<ul>
<li>undefined类型只有一个值<code>undefined</code></li>
<li>声明变量但未初始化会默认为变量赋值<code>undefined</code>，只要值是<code>undefined</code>，他的<code>typeof</code>就是<code>undefined</code></li>
<li>未声明的变量只能执行一项操作<code>typeof</code>，结果为<code>undefined</code>，也可以执行delete，但无意义</li>
</ul>
</li>
<li><p>Null类型</p>
<ul>
<li>null类型只有一个值<code>null</code>，表示一个空对象指针</li>
<li>undefined == null //true</li>
<li>在还不知道为一个变量声明时初始化什么值时，可以初始化为null</li>
<li>null和undefined本质上是不同的，语义不同</li>
</ul>
</li>
<li><p>Boolean类型</p>
<ul>
<li>只有<code>true</code>和<code>false</code>两个值</li>
<li>所有类型的值都有与这两个布尔值等价的值，可以通过<code>Boolean()</code>转换，任何类型都可以调用这个函数</li>
<li>转换规则<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">true</th>
<th align="center">false</th>
</tr>
</thead>
<tbody><tr>
<td align="center">String</td>
<td align="center">任何非空字符串</td>
<td align="center">“”（空字符串）</td>
</tr>
<tr>
<td align="center">Number</td>
<td align="center">任何非零数值(包括无穷大)</td>
<td align="center">0和NaN</td>
</tr>
<tr>
<td align="center">Object</td>
<td align="center">任何对象</td>
<td align="center">null</td>
</tr>
<tr>
<td align="center">Undefined</td>
<td align="center">N/A</td>
<td align="center">undefined</td>
</tr>
</tbody></table>
</li>
<li>流控制语句自动执行相应的布尔转换 </li>
</ul>
</li>
<li><p>Number类型</p>
<ul>
<li>使用IEEE754格式表示整数和字符串</li>
<li>数值字面量格式<ul>
<li>八进制：0开头，每位在0-7之间，否则按十进制解析</li>
<li>十六进制：0x开头，每位在0-9，A-F之间，否则报错</li>
<li>+0 == -0 //true</li>
<li>十进制：默认</li>
</ul>
</li>
<li>浮点数值<ul>
<li><code>.0 == 0.1</code></li>
<li><code>1. == 1</code>浮点数占空间是数值的两倍，所以会最大程度的把浮点数转换成整数</li>
<li><code>1.0 == 1</code>浮点数本身是整数会被转换成整数</li>
<li><code>e</code>科学计数法</li>
<li>浮点数的最高精度是17位，所以0.1+0.2=0.30000000000000004(15个0，小数点后17位)</li>
</ul>
</li>
<li>数值范围<ul>
<li>Number.MIN_VALUE: 5e-324<ul>
<li><code>Number.MIN_VALUE - Number.MIN_VALUE == 0</code></li>
<li><code>Number.MIN_VALUE - Number.MAX_VALUE == - Number.MAX_VALUE</code></li>
<li><code>Number.MIN_VALUE + Number.MIN_VALUE == 1e-323</code></li>
<li><code>Number.MIN_VALUE + Number.MAX_VALUE == Number.MAX_VALUE</code></li>
<li><code>Number.MIN_VALUE + 任何非零数 == 该非零数</code></li>
</ul>
</li>
<li>Number.MAX_VALUE: 1.7976931348623157e+308<ul>
<li><code>Number.MAX_VALUE - Number.MAX_VALUE == 0</code></li>
<li><code>Number.MAX_VALUE - Number.MIN_VALUE == Number.MAX_VALUE</code></li>
<li><code>Number.MAX_VALUE + Number.MAX_VALUE == Infinite</code></li>
<li><code>Number.MAX_VALUE + Number.MIN_VALUE == Number.MAX_VALUE</code></li>
<li>`Number.MIN_VALUE + 任何非零数 == Number.MAX_VALUE</li>
</ul>
</li>
<li>Number.NEGATIVE_INFINITE: -Infinite<ul>
<li><code>Number.NEGATIVE_INFINITE + Number.POSITIVE_INFINITE == NaN</code></li>
</ul>
</li>
<li>Number.POSITIVE_INFINITE: Infinite</li>
<li>isFinite()：用来检查数值是否有限</li>
</ul>
</li>
<li>NaN<ul>
<li>Not a Number,表示本来要返回数值的操作数未返回数值，是一个特殊的数值</li>
<li>任何涉及NaN的操作都会返回NaN</li>
<li>NaN与任何值都不相等<code>NaN == NaN //false</code></li>
<li>isNaN(),传入所有不能转换成数值的值和NaN会返回true</li>
</ul>
</li>
<li>数值转换<ul>
<li>三个函数可以把非数值转成数值：<code>Number()</code>、<code>parseInt()</code>、<code>parseFloat()</code></li>
<li>Number()<ul>
<li>传入布尔，1和0</li>
<li>传入数值，根据数值格式输出数值</li>
<li>传入null，返回0</li>
<li>传入undefined，返回NaN</li>
<li>传入字符串<ul>
<li>字符串中只包含数值和无意义的空格，返回数值的十进制</li>
<li>字符串中包含有效浮点格式，返回对应的浮点数值</li>
<li>字符串以0x开头的有效十六进制格式，返回对应的十进制整数</li>
<li>字符串为空，返回0</li>
<li>字符串中包含其他字符，返回NaN</li>
</ul>
</li>
<li>传入对象<ul>
<li>首先调用对象的<code>ValueOf()</code>方法，然后依照前面的规则转换返回值，如果结果是NaN，则调用对象的<code>toString()</code>方法，然后依照前面的规则转换返回的字符串</li>
</ul>
</li>
<li>Number()与一元加操作符的操作相同，即<code>+true == 1</code></li>
</ul>
</li>
<li>parseInt() <ul>
<li>会忽略字符串前面的空格，知道找到第一个非空格字符，若第一个字符不是数字或符号，则返回NaN<ul>
<li>parseInt(“   1”) == Number(“   1”)</li>
</ul>
</li>
<li>会一直解析直到遇到非数值<ul>
<li>parseInt(“1.2”) == 1</li>
<li>parseInt(“123bl”) == 123</li>
<li>parseInt(“0x) == NaN</li>
</ul>
</li>
<li>第二个参数，传入基数表示数字格式<ul>
<li>parseInt(“70”,8) //56 ，可忽略0开头</li>
<li>建议无论在何时都传入基数，默认10</li>
</ul>
</li>
</ul>
</li>
<li>parseFloat()<ul>
<li>解析直到第一个无效浮点数字符，可返回整数</li>
<li>没有第二个参数<ul>
<li>传入十六进制，返回0，因为到x就认定无效了</li>
<li>当有效数字不止一个0的时候忽略前置0，只解析十进制</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>String类型</p>
<ul>
<li>由0或多个16位Unicode字符组成的字符序列，用<code>&quot;&quot;</code>或<code>&#39;&#39;</code>表示</li>
<li>字符字面量<ul>
<li>转义序列<ul>
<li><code>\n</code> ：n表示newline，换行</li>
<li><code>\t</code> ：t表示table，就是一个tab的缩进</li>
<li><code>\b</code> ：b表示backspace，就是退格</li>
<li><code>\r</code> ：r表示return，回车</li>
<li><code>\f</code> ：f表示formfeed，进纸</li>
<li><code>\\</code> ：斜杠</li>
<li><code>\&#39;</code> ：单引号</li>
<li><code>\&quot;</code> ：双引号</li>
<li><code>\xnn</code> ：n表示十六进制，表示一个字符<ul>
<li>\x41 : A</li>
</ul>
</li>
<li><code>\unnnn</code> ：n表示十六进制，表示一个Unicode字符，六个字符长，表示一个字符<ul>
<li>\u03a3 : sigma</li>
<li>‘\u03a3’.lenght == 1</li>
</ul>
</li>
</ul>
</li>
<li>字符长度<ul>
<li>转义序列无论多长，只占一位</li>
</ul>
</li>
</ul>
</li>
<li>字符串特点<ul>
<li>字符串一旦创建就不可改变</li>
<li>要改变保存字符串的变量，直接将变量指向一个新字符串，旧的字符串会被销毁</li>
</ul>
</li>
<li>转换为字符串<ul>
<li>两种方式把一个值转为字符串：<code>toString()</code>和<code>String()</code></li>
<li>toString()<ul>
<li>数值、字符串、对象、布尔值都有toString()方法<ul>
<li>null和undefined没有</li>
<li>字符串也有，返回该字符串的一个副本</li>
</ul>
</li>
<li>传参<ul>
<li>数值调用toString()时，传入一个基数，来表示数值转换的进制数，默认十进制</li>
<li><code>var a = 10 ; a.toString(2) //&quot;1010&quot;</code></li>
</ul>
</li>
</ul>
</li>
<li>String()<ul>
<li>能将任何类型的值转换为字符串</li>
<li>转换规则<ul>
<li>如果值由toString()方法，则调用该方法，不传参</li>
<li>如果值是null，返回’null’</li>
<li>如果值是undefined，返回’undefined’</li>
</ul>
</li>
</ul>
</li>
<li>数字转字符串简单方法<ul>
<li><code>num + &quot;&quot;</code></li>
</ul>
</li>
<li>纯数字的字符串转数字<ul>
<li><code>+str</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Object类型</p>
<ul>
<li>一组数据和功能的集合</li>
<li>每个对象实例都具有的属性和方法<ul>
<li><code>constructor</code></li>
<li><code>hasOwnProperty(prototypeName)</code></li>
<li><code>isPrototypeOf(object)</code></li>
<li><code>prototypeIsEnumberable(prototypeName)</code></li>
<li><code>toLocalString()</code>返回对象的字符串表示，跟执行环境相关</li>
<li><code>toString()</code>返回对象的字符串表示。<code>￥￥￥</code></li>
<li><code>valueOf()</code><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><blockquote>
<p>主要分四大类：算数运算符、位运算符、关系操作符、相等操作符<br><br>ES中的操作符不同之处在于能够适用于多种类型的值，在应用对象时，会调用对象的valueOf或toString</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>一元操作符：只能操作一个值的操作符</p>
<ul>
<li>递增和递减操作符<ul>
<li><code>a++\++a</code></li>
<li><code>a--\--a</code></li>
</ul>
</li>
<li>一元加和一元减操作符<ul>
<li><code>+num</code></li>
<li><code>-num</code></li>
</ul>
</li>
</ul>
</li>
<li><p>位操作符</p>
<ul>
<li>二进制补码<ul>
<li>传统三步法<ul>
<li>绝对值的二进制码</li>
<li>反码</li>
<li>反码+1</li>
</ul>
</li>
<li>JavaScript输出负数<ul>
<li>绝对值的二进制码</li>
<li>前面加个负号</li>
</ul>
</li>
</ul>
</li>
<li>位操作符<ul>
<li>ES中对数值使用位操作符会将64位的数值转换成32位，进行位运算，最后转换回64位</li>
<li>NaN和Infinity被当做0来处理，对非数值进行位运算会先进行Number()chuli </li>
</ul>
</li>
<li>按位非(NOT) <code>~</code><ul>
<li><code>num == - ( ~ num + 1)</code></li>
</ul>
</li>
<li>按位与(AND) <code>&amp;</code></li>
<li>按位或(OR) <code>|</code></li>
<li>按位异或(XOR) <code>^</code><ul>
<li><code>(num1 ^ num2) == (num1 | num2) - (num1 &amp; num2)</code></li>
</ul>
</li>
<li>左移 <code>&lt;&lt;</code><ul>
<li>所有位数左移，腾出的空位用0补充，不会影响符号位，除非移到了第32位，超出32位为0</li>
</ul>
</li>
<li>有符号的右移 <code>&gt;&gt;</code><ul>
<li>符号位不动，其他位右移，腾出位用符号位的值来填充(负数用1填充，正数用0填充)</li>
</ul>
</li>
<li>无符号的右移 <code>&gt;&gt;&gt;</code><ul>
<li>32位整体右移</li>
<li>正数，与&gt;&gt;相同</li>
<li>负数，腾出位用0填充</li>
</ul>
</li>
</ul>
</li>
<li><p>布尔操作符</p>
<ul>
<li>逻辑非 <code>!</code></li>
<li>逻辑与 <code>&amp;&amp;</code></li>
<li>逻辑或 <code>||</code></li>
</ul>
</li>
<li><p>乘性操作符</p>
<ul>
<li>乘法 <code>*</code></li>
<li>除法 <code>/</code></li>
<li>求模 <code>%</code></li>
</ul>
</li>
<li><p>加性操作符</p>
<ul>
<li>加法 <code>+</code></li>
<li>减法 <code>-</code></li>
</ul>
</li>
<li><p>关系操作符</p>
<ul>
<li>小于 <code>&lt;</code></li>
<li>大于 <code>&gt;</code></li>
<li>小于等于 <code>&lt;=</code></li>
<li>大于等于 <code>&gt;=</code></li>
</ul>
</li>
<li><p>相等操作符</p>
<ul>
<li>相等 <code>==</code></li>
<li>不相等 <code>!=</code></li>
<li>全等 <code>===</code></li>
<li>不全等 <code>!==</code></li>
</ul>
</li>
<li><p>条件操作符</p>
<ul>
<li>问号 <code>a?b:c</code></li>
</ul>
</li>
<li><p>赋值操作符</p>
<ul>
<li>等号 <code>=</code></li>
</ul>
</li>
<li><p>逗号操作符</p>
<ul>
<li>用于赋值 <code>var a = (5, 1, 4)</code>，用于赋值时，逗号操作符会返回表达式中的最后一项</li>
<li>用于声明 <code>var a = 1, b = 2</code><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3></li>
</ul>
</li>
<li><p>if语句</p>
</li>
<li><p>do-while语句</p>
</li>
<li><p>while语句</p>
</li>
<li><p>for语句</p>
</li>
<li><p>for-in语句</p>
</li>
<li><p>label语句</p>
</li>
<li><p>break和continue语句</p>
</li>
<li><p>with语句</p>
</li>
<li><p>switch语句</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3></li>
<li><p>理解参数</p>
<ul>
<li>arguments对象<ul>
<li>是一个类数组，不是Array的实例<ul>
<li>arguments[],可以为空，所以ES的函数参数非必要</li>
<li>arguments.length</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>没有重载</p>
<ul>
<li>后面的声明会覆盖前面的声明</li>
</ul>
</li>
</ul>
<h2 id="4-变量、作用域和内存问题"><a href="#4-变量、作用域和内存问题" class="headerlink" title="4.变量、作用域和内存问题"></a>4.变量、作用域和内存问题</h2><h3 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h3><ul>
<li>变量的访问<ul>
<li>基本类型 <strong>按值访问</strong>，可以操作保存在变量中的实际的值</li>
<li>引用类型 <strong>按引用访问</strong>，实际的值是保存在内存中的对象，不能直接操作对象的内存空间。在为对象添加属性时，操作的是实际的对象，在复制保存着对象的某个变量时，操作的是对象的引用</li>
</ul>
</li>
<li>动态的属性<ul>
<li>引用类型可以动态的操作属性</li>
</ul>
</li>
<li>复制变量值<ul>
<li>基本类型复制的是值，两个值相同但互不相干</li>
<li>引用类型复制的是指针，两个指针指向内存空间中同一个对象</li>
</ul>
</li>
<li>传递参数<ul>
<li>无论传参是基本类型还是引用类型，<strong>都是按值传递</strong></li>
<li>参数实际上是函数的局部变量，用ES的概念说，是arguments对象中的一个元素</li>
<li>在函数内部重写一个全局对象时，这个之前的全局对象会变成一个局部对象，局部对象会在函数执行完毕后立即销毁</li>
</ul>
</li>
<li>检测类型<ul>
<li><code>typeof</code>方便检测基本类型</li>
<li><code>instanceof</code>方便检测引用类型</li>
</ul>
</li>
</ul>
<h3 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h3><ul>
<li><p>产生：当某个函数被调用时，会创建一个执行环境及相应的作用域链，然后用arguments和其他命名参数的值来初始化活动对象</p>
</li>
<li><p>执行环境：<code>execution context</code>也叫执行上下文，定义了变量或函数有权访问的其他数据，决定了它们各自的行为</p>
<ul>
<li>变量对象：环境中定义的所有变量和函数都保存在这个对象中。解析器在处理数据时会在后台使用这个对象,编码过程中无法访问这个对象</li>
<li>全局执行环境：最外围的一个执行环境，在web浏览器中，全局执行环境是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的</li>
<li>环境的销毁：某个执行环境中所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和属性定义也随之销毁。全局执行环境直到应用程序退出时才被销毁</li>
<li>执行流：每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境被推入一个环境栈中。在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境</li>
</ul>
</li>
<li><p>作用域链：指向变量对象的指针列表，只引用但不实际包含变量对象。保证对执行环境有权访问的所有变量和函数的有序访问</p>
<ul>
<li>作用域链的前端：始终都是当前执行的代码所在环境的变量对象<ul>
<li>如果执行环境是函数，将其 <strong>活动对象</strong>作为变量对象。活动对象最开始只包含arguments对象一个变量</li>
</ul>
</li>
<li>作用域链的最后端：始终都是全局执行环境的变量对象</li>
<li>中间：下一个变量对象来自下一个包含(外部)环境，直至延续到全局执行环境</li>
<li>标识符解析：沿着作用域链一级一级地搜索标识符的过程</li>
</ul>
</li>
<li><p>延长作用域链</p>
<ul>
<li>try-catch语句</li>
<li>with语句</li>
</ul>
</li>
<li><p>没有块级作用域</p>
<ul>
<li>es6补充let、const关键字</li>
</ul>
</li>
</ul>
<h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><ul>
<li>原理：找出不再使用的变量(打上记号)，然后周期性地释放其占用的内存。</li>
<li>标记清除(最主流)<ul>
<li>当变量进入环境时，为这个变量标记为“进入环境”，当变量离开环境时，则将其标记为“离开环境”</li>
<li>如何标记不重要，关键在于采取什么策略</li>
<li>垃圾收集器工作<ul>
<li>给存储在内存中的所有变量加上标记(加上进入环境的标签)</li>
<li>去掉环境中的变量以及被环境中变量引用的变量的标记(摘掉进入环境的标签)</li>
<li>环境中无法访问的变量加上标签(加上离开环境的标签)</li>
<li>内存清除，销毁哪些带标签的值并回收他们所占用的内存空间</li>
</ul>
</li>
</ul>
</li>
<li>引用计数<ul>
<li>原理：跟踪记录每个值被引用的次数</li>
<li>步骤：<ul>
<li>变量被声明时并被赋值一个引用类型值时，+1，该引用类型被赋值给另一个变量，+1</li>
<li>包含这个引用的变量又取得另一个值，-1，</li>
<li>当引用次数为0时，则可以销毁了</li>
</ul>
</li>
<li>引用计数的问题<ul>
<li>循环引用会导致次数永不为0，例如IE的DOM</li>
</ul>
</li>
<li>手动解决方案<ul>
<li>为了避免循环引用，赋值为null，手动解除引用</li>
</ul>
</li>
<li>内存泄露<ul>
<li>使用引用计数的垃圾清理机制会存在的问题，就是已经不再用到的内存，没有及时释放(次数不为0)</li>
</ul>
</li>
</ul>
</li>
<li>性能问题<ul>
<li>IE是通过动态修改几个字面量的临界值的方式来触发垃圾收集器<ul>
<li>256个变量</li>
<li>4096个对象</li>
<li>64kb字符串</li>
<li>触发任一临界值便会触发，定死临界值可能会频繁触发回收。所以需要动态修改临界值</li>
</ul>
</li>
<li>当垃圾收集例程回收的内存分配量低于15%(每次回收的内存占比不大，说明总是被清除)，上面的临界值加倍</li>
<li>当垃圾收集例程回收的内存分配量达到85%(每次回收的内存占比大，说明很久没被清除)，临界值重置默认值</li>
</ul>
</li>
<li>管理内存<ul>
<li>一旦数据不再有用，最好通过设置为null来释放引用，这个方法叫解除引用<ul>
<li><strong>解除引用</strong>并不是直接释放内存，而是方便垃圾收集器下次运行时将他带走</li>
</ul>
</li>
<li>局部变量会在他们离开执行环境时自动被解除引用</li>
</ul>
</li>
</ul>
<h2 id="5-引用类型"><a href="#5-引用类型" class="headerlink" title="5.引用类型"></a>5.引用类型</h2><ul>
<li>引用类型是一种数据结构，用于将数据和功能组织到一起。比如Array.push()，Array是数组，push是为数组增加元素的功能。</li>
<li>引用类型也是一种对象定义，描述一类对象所具有的的属性和方法</li>
<li>引用类型和类不是相同的概念，对象是引用类型的实例</li>
</ul>
<h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h3><h3 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h3><ul>
<li>检测数组<ul>
<li>instanceof操作符</li>
<li>Array.isArray(value)</li>
</ul>
</li>
<li>转换方法<ul>
<li>toString()</li>
<li>toLocalString()</li>
<li>valueOf()</li>
</ul>
</li>
<li>栈方法<ul>
<li>push()</li>
<li>pop()</li>
</ul>
</li>
<li>队列方法<ul>
<li>push()和shift()</li>
<li>unshift()和pop()</li>
</ul>
</li>
<li>重排序方法<ul>
<li>reverse()</li>
<li>sort()</li>
</ul>
</li>
<li>操作方法<ul>
<li>concat</li>
<li>slice</li>
<li>splice</li>
</ul>
</li>
<li>位置方法<ul>
<li>indexOf</li>
<li>lastIndexOf</li>
</ul>
</li>
<li>迭代方法<ul>
<li>every</li>
<li>filter</li>
<li>forEach</li>
<li>map</li>
<li>some</li>
</ul>
</li>
<li>归并方法<ul>
<li>reduce</li>
<li>reduceRight<h3 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h3><h3 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h3></li>
</ul>
</li>
<li>格式：<code>var expression = / pattern / flags ;</code><ul>
<li>pattern表示正则表达式</li>
<li>flags表示标志<ul>
<li>g：表示全局模式，即正则应用到字符串全局，并非第一个处</li>
<li>i：表示不区分大小写模式</li>
<li>m：表示多行模式</li>
</ul>
</li>
</ul>
</li>
<li>RegExp构造函数<ul>
<li>两个参数<ul>
<li>字符串模式<ul>
<li>需要双重转义</li>
</ul>
</li>
<li>标志字符串<h3 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h3><h3 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h3><h3 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h3></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-面向对象的程序设计"><a href="#6-面向对象的程序设计" class="headerlink" title="6.面向对象的程序设计"></a>6.面向对象的程序设计</h2><h3 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h3><ul>
<li>属性类型：为了实现JavaScript引擎，在JavaScript中不能直接访问它们<ul>
<li>数据属性：包含一个数据值的位置，在这个位置可以读写值，有4个描述行为特性的描述符<ul>
<li><code>[[Configurable]]</code>表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性、能否把属性修改为访问器属性<ul>
<li>一旦把属性定义为不可配置的，就不能再把它变回可配置的了</li>
</ul>
</li>
<li><code>[[Enumerable]]</code>表示能否通过for——in循环返回属性</li>
<li><code>[[writable]]</code>表示能否修改属性的值</li>
<li><code>[[value]]</code>表示这个属性的数据值</li>
</ul>
</li>
<li>访问器属性：不包含数据值，包含一对getter和setter函数(非必需)<ul>
<li>不能直接定义，必须使用defineProperty来定义</li>
<li><code>[[Configurable]]</code>同上</li>
<li><code>[[Enumerable]]</code>同上</li>
<li><code>[[Get]]</code>在读取属性时调用的函数。默认值undefined</li>
<li><code>[[Set]]</code>在写入属性时调用的函数。默认值undefined</li>
<li>使用方式同数据属性，使用访问器属性的常见方式是设置一个属性的值会导致其他属性发生变化。</li>
</ul>
</li>
<li><code>Object.defineProperty()</code>:修改一个属性默认的特性<ul>
<li>接受三个参数：属性所在对象，属性名，一个描述符对象</li>
<li>描述符对象的属性为：configurable、enumerable、writable、value</li>
</ul>
</li>
</ul>
</li>
<li>定义多个属性：<code>Object.defineProperties()</code><ul>
<li>接收两个参数:属性所在对象，属性名和描述符对象的键值对对象</li>
<li>所有的属性都是在同一时间创建的</li>
</ul>
</li>
<li>读取属性的特性:<code>Object.getOwnPropertyDescriptor()</code><ul>
<li>接收两个参数：属性所在对象、要读取其描述符的属性名</li>
<li>返回值是一个对象，对象的属性视数据属性和访问器属性而不同</li>
</ul>
</li>
</ul>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ul>
<li><p>工厂模式</p>
<ul>
<li>用简单的函数创建对象，为对象添加属性和方法，然后返回对象</li>
<li>基本思路：抽象创建具体对象的过程，封装以特定接口创建对象的细节</li>
</ul>
</li>
<li><p>构造函数模式</p>
<ul>
<li>创建自定义引用类型，像创建内置对象实例一样使用new操作符创建引用类型实例</li>
<li>和工厂模式的区别<ul>
<li>没有显式的创建对象 <code>new Object()</code></li>
<li>直接将属性和方法赋给了<code>this</code>对象</li>
<li>构造函数没有<code>return</code>语句</li>
</ul>
</li>
<li>用 <code>new</code> 构造函数创建实例，会经历4个步骤<ul>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象(为了this指向新对象)</li>
<li>执行构造函数中的代码</li>
<li>返回新对象</li>
</ul>
</li>
<li><code>实例名.constructor == 构造函数名      //true</code></li>
<li><code>实例名 instanceof 构造函数名/Object   //true</code></li>
<li>问题：每个方法都要在每个实例上重新创建一遍<ul>
<li><code>person1.方法 == person2.方法    //false</code></li>
<li>可以把方法的定义转移到构造函数外部，而在构造函数内部，将方法属性设置成等于这个全局方法(保存指向这个全局方法的指针)<ul>
<li>这样做多了就会使封装性减弱</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>原型模式</p>
<ul>
<li><p>基本思路：使用构造函数的<code>prototype</code>属性来指定哪些应该共享的属性和方法</p>
<ul>
<li>创建的每一个函数都有一个<code>prototype</code>属性，保存着指向一个对象的指针，这个对象的用途是包含所有实例 <strong>可共享</strong>的属性和方法。</li>
<li><code>prototype</code>是通过调用构造函数而创建的那个实例的原型对象，可以不必在构造函数中定义对象实例的信息</li>
</ul>
</li>
<li><p><strong>原型对象</strong></p>
<ul>
<li><code>Function.prototype</code>:每创建一个函数，就会创建一个prototype属性，该属性指向函数的原型对象</li>
<li><code>Function.prototype.constructor</code>:所有的原型对象会自动获取一个constructor属性，指向prototype属性所在函数<ul>
<li><code>Person.prototype.constructor == Person</code></li>
</ul>
</li>
<li><code>实例.__proto__</code>:当调用构造函数创建一个实例后，这个实例中会包含一个指向构造函数原型对象的指针<code>[[prototype]]</code>，在浏览器上是的体现是每个实例对象上有一个 <code>__proto__</code>属性</li>
<li>总结：实例的属性中会有<code>__proto__</code>属性指向原型对象，构造函数中会有<code>prototype</code>属性指向原型对象，原型对象中会有<code>constructor</code>属性指向构造函数</li>
<li><code>isPrototypeOf()</code><ul>
<li><code>Person.prototype.isPrototypeOf(person1) //true</code></li>
</ul>
</li>
<li><code>Object.getPrototypeOf()</code><ul>
<li><code>Object.getPrototypeOf(person1) == Person.prototype //true</code></li>
</ul>
</li>
<li>原型搜索机制<ul>
<li>原理：对象实例共享原型所保存的属性和方法</li>
<li>当读取某个对象的某个属性时<ul>
<li>首先会搜索对象实例本身，如果找到给定的属性或方法名，则返回</li>
<li>若没找到，则对对象实例的原型对象进行第二次搜索，如果找到，则返回</li>
</ul>
</li>
</ul>
</li>
<li><code>hasOwnProperty()</code>：检测一个属性是在实例中还是在原型中。该方法继承自Object<ul>
<li><code>person1.hasOwnProperty(&quot;name&quot;)    //false  表示属性在原型中</code></li>
</ul>
</li>
</ul>
</li>
<li><p>原型与in操作符</p>
<ul>
<li><code>in</code>：无论是实例本身还是原型的属性，只要能访问就为true<ul>
<li><code>&quot;name&quot; in person  //true</code></li>
</ul>
</li>
<li><code>for-in</code>:返回的是所有可通过对象访问的，enumerated的属性<ul>
<li>包括存在于实例的属性，也包括存在与原型的属性</li>
<li>会屏蔽原型中不可枚举的属性(即[[enumerable]]设置为false的属性)，但实例属性覆盖该原型属性后是可以的</li>
<li>所有开发人员定义的属性都是可枚举的 </li>
</ul>
</li>
<li><code>Object.keys(原型对象)</code>:返回一个所有可枚举属性的字符串数组<ul>
<li><code>Object.keys(Person.prototype)     //name,age,job,sayName</code></li>
</ul>
</li>
<li><code>Object.getOwnPropertyNames(原型对象)</code>：返回所有属性的字符串数组<ul>
<li><code>Object.getOwnPropertyNames(Person.prototype)  //constructor,name,age,job,sayName</code></li>
</ul>
</li>
</ul>
</li>
<li><p>对象字面量方式重写原型对象</p>
<ul>
<li>重写原型就切断了现有实例与新原型的联系</li>
<li>新原型的<code>constructor</code>不再指向<code>Person</code>,而是<code>Object</code>。因为重写了原型对象，这个原型就是Object的实例，它的constructor属性也就指向了最顶层Object<ul>
<li><code>person1 instanceof Person</code>//true</li>
<li><code>person1.constructor == Person</code>//false</li>
</ul>
</li>
<li>解决方法<ul>
<li>对象字面量中加一条<code>constructor : Person,</code>。但是会产生一个新的问题：constructor变成可枚举的属性。</li>
<li><code>Object.defineProperty</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">    enumerable : fasle,</span><br><span class="line">    value : Person</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>原型的动态性</p>
<ul>
<li>在通过构造函数创建实例之后修改原型对象<ul>
<li>对原型对象内部做任何修改都能够立即从实例上反映出来</li>
<li>如果修改的是整个原型对象，则不具有动态性<ul>
<li>重写原型就切断了原本原型和构造函数之间的联系。</li>
<li>此时构造函数的prototype属性指向重写后的原型。</li>
<li>而先前创建的实例中的指针仅指向重写前的原型，而不指向重写后的原型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>原生对象的原型</p>
<ul>
<li>原生引用类型(Object、Array、String等)都在其构造函数的原型上定义了方法</li>
<li>不推荐在原生对象的原型上定义新方法</li>
</ul>
</li>
<li><p>原型对象的问题</p>
<ul>
<li>在修改基本类型的属性时，问题不大，因为同名属性会直接覆盖</li>
<li>在修改包含引用类型值的属性时，问题很大，所有实例中的属性都会做出修改</li>
</ul>
</li>
</ul>
</li>
<li><p>组合使用构造函数模式和原型模式</p>
<ul>
<li>构造函数模式用于定义实例属性，原型模式用于定义方法和共享属性</li>
<li>优点：<ul>
<li>支持向构造函数传递参数</li>
<li>每个实例都会有自己的一份实例属性副本</li>
<li>共享着方法的引用，最大限度节省内存</li>
</ul>
</li>
</ul>
</li>
<li><p>动态原型模式</p>
<ul>
<li>把所有信息都封装在构造函数中，而仅在必要的情况下(第一次被调用时)通过在构造函数中初始化原型<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"Function"</span>)&#123;<span class="comment">//语句检查可以是任何属性或方法</span></span><br><span class="line">    Person.prototype.sayName = <span class="built_in">Function</span>()&#123;<span class="comment">//不要用对象字面量方式重写原型对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>寄生构造函数模式</p>
<ul>
<li>类似工厂模式：除了使用new操作符和把包装函数称之为构造函数之外和工厂模式一模一样</li>
<li>优点 <ul>
<li>可以重写调用构造函数时return的值。普通构造函数只能返回新对象实例</li>
<li>可以用来创建有额外方法的引用类型，如创建一个类似Array的构造函数</li>
</ul>
</li>
<li>缺点<ul>
<li>顾名思义，寄生。返回的对象与构造函数和构造函数的原型之间没有关系</li>
</ul>
</li>
<li>不推荐</li>
</ul>
</li>
<li><p>稳妥构造函数模式</p>
<ul>
<li>稳妥对象：没有公共属性，其方法不引用this关键字</li>
<li>适用于不允许使用this和new的安全环境中</li>
<li>类似寄生构造函数模式;与寄生构造函数模式的区别：<ul>
<li>新创建对象的实例方法不引用this</li>
<li>不使用new操作符调用构造函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li><p>原型链:实现继承的主要方法</p>
<ul>
<li>基本思路：利用原型让一个引用类型继承另一个引用类型的属性和方法</li>
<li>原型搜索机制拓展：搜索子对象实例-&gt;搜索子对象原型-&gt;搜索超对象原型直至找到为止</li>
<li><code>Object.prototype</code>:默认的原型。原型链的最顶层<ul>
<li>所有引用类型默认都继承了Object</li>
<li>所有函数的默认原型都是Object的实例 <code>Function.prototype = new Object()</code> </li>
</ul>
</li>
<li><code>instanceof</code>：确定原型和实例的关系，子实例是原型链中任何一个类型的实例</li>
<li><code>isPrototypeOf()</code>同<code>instanceof</code></li>
<li>给原型添加方法的代码一定要放在替换原型的语句之后</li>
<li>通过原型链实现继承时，不能使用对象字面量创建原型方法，字面量添加新方法会破坏继承</li>
<li>原型链的问题<ul>
<li>通过原型链来实现继承时，原型会变成另一个类型的实例。原先的实例属性就变成了原型属性，即会被共享</li>
<li>创建子类型的实例时，不能向超类型的构造函数中单独传递参数</li>
</ul>
</li>
</ul>
</li>
<li><p>借用构造函数(伪造对象或经典继承)技术</p>
<ul>
<li>基本思路：在子类型构造函数内部调用超类型的构造函数</li>
<li>实现：通过使用<code>apply</code>和<code>call</code>方法在将来新创建的对象上执行构造函数</li>
<li>传递参数<ul>
<li><code>superType.call(this,arg1,arg2)</code></li>
<li><code>superType.apply(this,[arg1,arg2])</code>     </li>
</ul>
</li>
<li>借用构造函数的问题<ul>
<li>函数复用率低</li>
</ul>
</li>
</ul>
</li>
<li><p>组合继承(伪经典继承)：将原型链和借用构造函数的技术组合到一块</p>
<ul>
<li>基本思路：使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承</li>
<li>是JavaScript最常用的继承模式</li>
<li>组合继承的问题：每次都会调用两次超类型的构造函数，继承两次实例属性<ul>
<li>一次是创建子类型原型时继承实例属性</li>
<li>一次是在子类型构造函数内部继承实例属性</li>
</ul>
</li>
</ul>
</li>
<li><p>原型式继承</p>
<ul>
<li><p>基本思路：借助原型基于 <strong>已有的对象</strong>创建新对象(克隆)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;      <span class="comment">//新建一个临时性的构造函数</span></span><br><span class="line">    F.prototype = o;    <span class="comment">//将传入的对象作为这个构造函数的原型对象，这里只是浅复制了传入对象o的指针。意思就是这个对象o是外部共享的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();     <span class="comment">//返回这个构造函数的新实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Object.create()</code>:ES5新增用来规范化原型式继承，接受两个参数</p>
<ul>
<li>用作新对象原型的对象</li>
<li>(可选)为新对象定义额外属性的对象</li>
</ul>
</li>
<li><p>使用场景：想让一个对象和另一个对象保持类似时</p>
</li>
</ul>
</li>
<li><p>寄生式继承</p>
<ul>
<li><p>基本思路：和寄生构造函数和工厂模式类似，创建一个仅用于封装继承过程的函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">origObj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cloneObj = object(origObj);</span><br><span class="line">    cloneObj.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> cloneObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用场景：主要考虑的是对象而不是自定义类型和构造函数时</p>
</li>
</ul>
</li>
<li><p>寄生组合式继承</p>
<ul>
<li><p>基本思路：通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，直接将超类型的原型赋值给子类型的原型，而不是将超类型的实例赋值给子类型原型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheirtPrototype</span>(<span class="params">SubType, SuperType</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cloneSuperPrototype = create(SuperType.prototype);<span class="comment">//创建对象</span></span><br><span class="line">    cloneSuperPrototype.contructor = SubType;   <span class="comment">//增强对象</span></span><br><span class="line">    SubType.prototype = cloneSuperPrototype;    <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最理想的继承范式</p>
</li>
</ul>
</li>
</ul>
<h2 id="7-函数表达式"><a href="#7-函数表达式" class="headerlink" title="7.函数表达式"></a>7.函数表达式</h2><ul>
<li><p>定义函数</p>
<ul>
<li><p>函数声明</p>
<ul>
<li>FSCO四大浏览器定义了name属性 <code>fun.name == &#39;fun&#39;</code></li>
<li>函数声明提升：执行代码之前会先读取函数声明，可以把函数声明放在函数调用之后</li>
</ul>
</li>
<li><p>函数表达式</p>
<ul>
<li>创建一个匿名函数(拉姆达函数)赋值给一个变量，匿名函数的name为空字符串<code>&#39;&#39;</code></li>
<li>和其他表达式一样，使用前必须先赋值，不存在变量提升</li>
</ul>
</li>
<li><p>命名函数表达式</p>
<ul>
<li><p>严格模式下，不能通过脚本访问arguments.callee时，可在递归函数中使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"><span class="keyword">var</span> factorial = (</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> n * f(n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>将函数赋值给另一个变量，函数名字f仍然有效。在严格模式和非严格模式都可以</p>
</li>
<li><p>此时name属性指向f而不是factorial</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul>
<li><p>递归函数是一个通过名字调用自身的函数</p>
</li>
<li><p>通过名字递归的问题</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherFactorial = factorial;   <span class="comment">//factorial为递归方法实现的阶乘函数</span></span><br><span class="line">factorial = <span class="literal">null</span>;</span><br><span class="line">anotherFactorial(<span class="number">4</span>);    <span class="comment">//此时函数内部的facotorial(3)已经不再能执行了</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>arguments.callee</code>：一个指向正在执行的函数的指针</p>
</li>
<li><p>严格模式下，使用命名函数表示来达成相同的效果</p>
</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li><p>作用域链：指向变量对象的指针列表，只引用但不实际包含变量对象。保证对执行环境有权访问的所有变量和函数的有序访问</p>
<ul>
<li>作用域链的前端：始终都是当前执行的代码所在环境的变量对象<ul>
<li>如果执行环境是函数，将其 <strong>活动对象</strong>作为变量对象。活动对象最开始只包含arguments对象一个变量</li>
</ul>
</li>
<li>作用域链的最后端：始终都是全局执行环境的变量对象</li>
<li>中间：下一个变量对象来自下一个外部环境，直至延续到全局执行环境</li>
<li>标识符解析：沿着作用域链一级一级地搜索标识符的过程</li>
</ul>
</li>
<li><p>函数的生命周期</p>
<ul>
<li>创建函数时，会创建一个预先包含全局变量对象的 <strong>作用域链</strong>，这个作用域链被保存在内部的<code>[[scope]]</code>属性中</li>
<li>调用函数时<ul>
<li>自动取得两个特殊变量<code>this</code>和<code>arguments</code></li>
<li>会为函数创建一个 <strong>执行环境</strong>，然后通过复制函数的<code>[[scope]]</code>属性中的对象构建起执行环境的作用域链。</li>
<li>函数的活动对象被创建并被推入执行环境作用域链的前端</li>
</ul>
</li>
<li>访问函数中的变量时，从作用域链中搜索相应名字的变量</li>
<li>函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域(全局执行环境的变量对象)</li>
</ul>
</li>
<li><p>闭包:指有权访问另一个函数作用域中的变量的函数(内部函数是其包含函数的闭包)</p>
<ul>
<li>闭包会携带包含函数的作用域(内存中存储包含函数的变量对象)和全局作用域，会比其他函数占用更多内存</li>
<li>闭包的作用<ul>
<li>在JavaScript中模仿块级作用域</li>
<li>用以在对象中创建私有变量(闭包实现能够访问包含作用于中变量的公有方法)</li>
</ul>
</li>
</ul>
</li>
<li><p>闭包与变量</p>
<ul>
<li>闭包只能取得包含函数中任何变量的最后一个值(在循环中的闭包要注意)</li>
</ul>
</li>
<li><p>this对象：基于函数运行时环境绑定的</p>
<ul>
<li><p>全局函数中，this等于window</p>
</li>
<li><p>当函数作为对象的方法调用时，this等于那个对象</p>
</li>
<li><p>匿名函数的this指向window，因为匿名函数是全局执行环境</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"window"</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">'obj'</span>,</span><br><span class="line">    getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>obj.getName()</code>//obj<br><code>(obj.getName)()</code>//obj，因为obj.getName和(obj.getName)定义一样<br><code>(obj.getName = obj.getName)()</code>//window ,因为赋值表达式的值是匿名函数本身</p>
</li>
</ul>
</li>
<li><p>内存泄露</p>
<ul>
<li>闭包作用域链中不要保存HTML元素，不然该元素无法被销毁</li>
<li>闭包会引用包含函数的整个活动对象</li>
<li>在用完一个变量后，把它设为null<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"x"</span>);</span><br><span class="line"><span class="keyword">var</span> id = element.id</span><br><span class="line">element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       alert(id)</span><br><span class="line">&#125;</span><br><span class="line">element = <span class="literal">null</span> <span class="comment">//解除对DOM对象的引用</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h3><ul>
<li><p>JavaScript没有块级作用域的概念</p>
<ul>
<li><p>变量提升</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'jimmy'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'lzm'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a() <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>for循环：</p>
<ul>
<li>i在循环结束后还会存在，因为i定义在for循环的包含函数的活动对象中</li>
<li>即使在循环结束后重新声明i(var i)也没用，因为前面的i还在，会无视后续的声明</li>
</ul>
</li>
</ul>
</li>
<li><p>匿名函数用作块级作用域(私有作用域)</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//这是块级作用域，ES6后被let\const取代</span></span><br><span class="line">&#125;)()<span class="comment">//函数表达式之后才能跟圆括号，比如f()</span></span><br></pre></td></tr></table></figure>

<ul>
<li>匿名函数放在圆括号里，表示是一个函数表达式；之后的圆括号表示会立刻调用这个函数</li>
<li>这个匿名函数被用作块级作用域时会是一个闭包</li>
<li>这种用法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用</li>
</ul>
</li>
</ul>
<h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><ul>
<li>任何函数中定义的变量，都可以认为是私有变量。私有变量包含函数的参数、局部变量、函数内部定义的其他函数</li>
<li>公有方法：可以访问包含作用于中定义的变量的方法</li>
<li>特权方法：是闭包，有权访问私有变量和私有函数的公有方法<ul>
<li>在构造函数中定义特权方法</li>
<li>静态私有变量：通过私有作用域中定义私有变量或函数创建特权方法<ul>
<li>函数声明只能创建局部函数</li>
<li>非严格模式下，初始化未经声明的变量,总是会创建一个全局变量</li>
</ul>
</li>
<li>多查找作用域中的一个层次，就会在一定程度上影响查找速度。这正是使用闭包和私有变量的一个不足之处</li>
</ul>
</li>
<li>模块模式<ul>
<li>单例特权方法</li>
</ul>
</li>
<li>增强的模块模式</li>
</ul>
<h2 id="8-BOM"><a href="#8-BOM" class="headerlink" title="8.BOM"></a>8.BOM</h2><ul>
<li>ES是JavaScript的核心，BOM是web环境下JavaScript的核心</li>
<li>BOM提供了很多对象，用于访问浏览器的功能。这些功能与页面内容无关</li>
</ul>
<h3 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h3><ul>
<li><p>概念</p>
<ul>
<li>window对象是BOM的核心对象,表示浏览器的实例</li>
<li>两个角色：访问浏览器窗口的JSAPI;ES中的Global对象</li>
</ul>
</li>
<li><p>全局作用域</p>
<ul>
<li>window对象扮演中ES中Global对象的角色</li>
<li><code>var a</code> 和 <code>window.a</code> 的区别<ul>
<li><code>var</code>语句声明的全局变量不能通过delete操作符删除。因为使用<code>var</code>语句添加的<code>winodw</code>属性有一个名为<code>[[configurable]]</code>的特性，这个特性值被设置为false</li>
</ul>
</li>
<li>尝试访问未声明的变量会抛错，这时可以通过<code>window.unknowValue</code>查看该变量是否存在,未声明则值为undefined.</li>
</ul>
</li>
<li><p>窗口关系及框架</p>
<ul>
<li><code>&lt;frame&gt;</code>标签已被新标准废弃，使用 <code>&lt;iframe&gt;</code></li>
<li>使用框架会使浏览器存在多个Global对象</li>
<li><code>top</code>指向最高层的frame,即浏览器窗口window</li>
<li><code>parent</code>指向当前frame的上层frame</li>
<li><code>window == self</code>引入<code>self</code>是为了和<code>top</code>、<code>parent</code>对应起来</li>
</ul>
</li>
<li><p>窗口位置</p>
<ul>
<li><p><code>screenLeft</code>/<code>screenTop</code>IE、Safari、Opera、Chrome</p>
</li>
<li><p><code>screenX</code>/<code>screenY</code>FireFox、Safari、Chrome</p>
</li>
<li><p>跨浏览器取的窗口位置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> winPosLeft = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">'number'</span>) ? </span><br><span class="line">                    <span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> winPosTop = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">'number'</span>) ? </span><br><span class="line">                    <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>moveTo(0,100)</code>窗口移动到新位置的xy值</p>
</li>
<li><p><code>moveBy(0,100)</code>窗口向水平和垂直方向移动的像素值</p>
<ul>
<li>默认被禁用，不适用于frame，只能对最外层window对象使用</li>
</ul>
</li>
</ul>
</li>
<li><p>窗口大小</p>
<ul>
<li>浏览器窗口内容区域宽高，包括水平/垂直滚动条(如果有的话)<ul>
<li><code>innerWidth</code></li>
<li><code>innerHeight</code></li>
</ul>
</li>
<li>浏览器窗口的宽高<ul>
<li><code>onnerWidth</code></li>
<li><code>onnerHeight</code></li>
</ul>
</li>
<li><code>document.documentElement.clientWidth</code>(后面补充)</li>
<li><code>document.body.clientWidth</code>混杂模式</li>
<li><code>resizeTo(0,100)</code></li>
<li><code>resizeBy(0,100)</code><ul>
<li>使用方法同moveTo/moveBy</li>
</ul>
</li>
</ul>
</li>
<li><p>导航和打开窗口</p>
<ul>
<li><code>window.open()</code>导航到一个特定的URL或者打开一个新的浏览器窗口<ul>
<li>可以接收4个参数<ul>
<li>要加载的URL</li>
<li>窗口目标<ul>
<li>自定义的窗口名或frame名</li>
<li><code>_parent</code></li>
<li><code>_self</code></li>
<li><code>_top</code></li>
<li><code>_blank</code></li>
</ul>
</li>
<li>一个特性字符串<ul>
<li>在不打开新窗口的情况下，会忽略这个参数</li>
<li><code>fullscreen</code>是否最大化</li>
<li><code>height</code>新窗口高度</li>
<li><code>left</code>新窗口左坐标</li>
<li><code>location</code>是否在浏览器窗口中显示地址栏</li>
<li><code>menubar</code>是否在浏览器窗口中显示菜单栏</li>
<li><code>resizable</code>是否可以通过拖动浏览器窗口的边框改变大小</li>
<li><code>scrollbars</code>是否允许滚动</li>
<li><code>status</code>是否显示状态栏</li>
<li><code>toolbar</code>是否显示工具栏</li>
<li><code>top</code>新窗口的上坐标</li>
<li><code>width</code>新窗口的宽度</li>
</ul>
</li>
<li>一个表示新页面是否取代浏览器历史记录当中加载页面的布尔值</li>
</ul>
</li>
<li>返回值是一个指向新窗口的引用</li>
</ul>
</li>
<li><code>新窗口引用.close()</code>关闭新打开的窗口</li>
<li><code>新窗口引用.closed</code>检测是否关闭//true</li>
<li><code>新窗口引用.opener</code>保存着原始窗口对象</li>
</ul>
</li>
<li><p>间歇调用和超时调用</p>
<ul>
<li><code>setTimeout()</code>指定时间后执行代码<ul>
<li>第一个参数是要执行的代码<ul>
<li>可以是一个包含JS代码的字符串，不建议</li>
<li>可以是一个函数</li>
</ul>
</li>
<li>第二个参数是以毫秒表示的时间</li>
<li>返回值是一个数值ID,表示这个超时调用，这个ID是这个计划执行代码的唯一标识符，后面可通过这个标识符用<code>clearTimeout(timeoutId)</code>取消超时调用</li>
</ul>
</li>
<li><code>setInterval()</code>指定周期执行代码，直至被取消或页面被卸载<ul>
<li>参数同<code>setTimeout</code></li>
<li><code>clearInterval(intervalId)</code>取消周期执行代码</li>
</ul>
</li>
</ul>
</li>
<li><p>系统对话框</p>
<ul>
<li><code>alert()</code></li>
<li><code>confirm()</code>返回值为{OK:True,Cancel:False}</li>
<li><code>prompt()</code><ul>
<li>第一个参数是显示给用户的文本提示</li>
<li>第二个参数是文本输入框的默认值</li>
<li>返回值是{OK：文本输入框的值,Cancel：null}</li>
</ul>
</li>
<li><code>window.print()</code>弹出打印对话框</li>
<li><code>window.find()</code>弹出查找对话框</li>
</ul>
</li>
</ul>
<h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><ul>
<li>概念<ul>
<li>最有用的BOM对象之一</li>
<li>提供了当前窗口中加载文档的有关信息，还提供了一些导航功能</li>
<li>即使window对象的属性也是document对象的属性<ul>
<li><code>window.location == document.location</code></li>
</ul>
</li>
<li><code>hash</code>:<code>#content</code></li>
<li><code>host</code>:<code>www.xx.com:80</code></li>
<li><code>hostname</code>:<code>www.xx.com</code></li>
<li><code>pathname</code>:<code>/demo/</code></li>
<li><code>port</code>:<code>8080</code></li>
<li><code>protocol</code>:<code>http:</code></li>
<li><code>search</code>:<code>?a=1&amp;b=2</code></li>
</ul>
</li>
<li>查询字符串参数<ul>
<li><code>location.search</code>返回从问号到URL末尾的所有内容</li>
<li>想逐个访问每个查询字符串的参数，可自定义函数截取字符串</li>
</ul>
</li>
<li>位置操作<ul>
<li><code>location.assign(URL)</code>立即打开新URL并在浏览器的历史记录中生成一条记录<ul>
<li><code>window.location = URL</code></li>
<li><code>location.href = URL</code>是最常用改变浏览器位置的操作</li>
<li>这两行代码和显式调用assign()的效果一样</li>
</ul>
</li>
<li><code>location.replace(URL)</code>会导致浏览器位置改变，但不会再历史记录中生成新纪录</li>
<li><code>location.reload()</code>从浏览器缓存中重新加载当前显示页面<ul>
<li><code>location.reload(true)</code>强制从服务器重新加载</li>
<li>最好将reload放在代码最后一行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><ul>
<li>用来识别客户端浏览器的事实标准，navigator对象的属性通常用于检测显示页面的浏览器类型</li>
<li>检测插件<ul>
<li><code>navigator.plugins[]</code></li>
</ul>
</li>
<li>注册处理程序</li>
</ul>
<h3 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h3><ul>
<li>用来表明客户端的能力<ul>
<li>浏览器窗口外部的显示器的信息</li>
</ul>
</li>
</ul>
<h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><ul>
<li>保存着用户上网的历史记录,无法得知用户浏览过的URL</li>
<li><code>history.go()</code><ul>
<li>负数表示向后跳转</li>
<li>正数表示向前跳转</li>
<li>字符串表示跳转到最近(前后都行)的包含这个字符串的历史记录</li>
</ul>
</li>
<li><code>history.back()</code>后退一页</li>
<li><code>history.forward()</code>前进一页</li>
<li><code>hsitory.length</code>历史记录的数量</li>
</ul>
<h2 id="9-客户端检测-检测是啥浏览器"><a href="#9-客户端检测-检测是啥浏览器" class="headerlink" title="9.客户端检测(检测是啥浏览器)"></a>9.客户端检测(检测是啥浏览器)</h2><h3 id="能力监测"><a href="#能力监测" class="headerlink" title="能力监测"></a>能力监测</h3><h3 id="怪癖检测"><a href="#怪癖检测" class="headerlink" title="怪癖检测"></a>怪癖检测</h3><h3 id="用户代理检测"><a href="#用户代理检测" class="headerlink" title="用户代理检测"></a>用户代理检测</h3><h2 id="10-DOM"><a href="#10-DOM" class="headerlink" title="10.DOM"></a>10.DOM</h2><ul>
<li>DOM是针对HTML和XML的一个API，描绘了一个层次化的的节点树，允许开发人员添加、修改、删除页面的某一部分<h3 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h3><blockquote>
<p>DOM将任何HTMl和XML文档描绘成一个由多层节点构成的结构，节点分为几种不同的类型，每种类型分别表示文档中不同的信息或标记。例如在HTML页面中，文档节点只有一个子节点html元素，html元素被称为文档元素</p>
</blockquote>
</li>
<li>Node类型<ul>
<li>总共有12种节点类型，这些类型都继承自Node类型</li>
<li>每个节点都有一个<code>nodeType</code>属性，可以查看节点的属性，节点的类型由在Node类型中定义的12个常量表示<ol>
<li><strong>Node.ELEMENT_NODE</strong> </li>
<li>Node.ATTRIBUTE_NODE</li>
<li><strong>Node.TEXT_NODE</strong> </li>
<li>Node.CDATA_SECTION_NODE</li>
<li>Node.ENTITY_REFERENCE_NODE</li>
<li>Node.ENTITY_NODE</li>
<li>Node.PROCESSING_INSTRUCTION_NODE</li>
<li>Node.COMMENT_NODE</li>
<li>Node.DOCUMENT_NODE</li>
<li>Node.DOCUMENT_TYPE_NODE</li>
<li>Node.DOCUMENT_FRAGMENT_NODE</li>
<li>Node.NOTATION_NODE</li>
</ol>
</li>
<li><code>nodeName</code>和<code>nodeValue</code>属性<ul>
<li>可以通过这两个属性了解节点的具体信息，属性值完全取决于节点类型，最好在使用前，检测一下节点类型<ul>
<li>对于元素节点，nodeName保存的是元素的标签名，nodeValue为null</li>
</ul>
</li>
</ul>
</li>
<li>节点关系<ul>
<li><code>childNodes</code>属性<ul>
<li>保存着一个NodeList对象，是一个类数组对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Document类型</li>
<li>Element类型</li>
<li>Text类型</li>
<li>Comment类型</li>
<li>CDATASection类型</li>
<li>DocumentType类型</li>
<li>DocumentFragment类型</li>
<li>Attr类型</li>
</ul>
<h3 id="DOM操作技术"><a href="#DOM操作技术" class="headerlink" title="DOM操作技术"></a>DOM操作技术</h3><ul>
<li>动态脚本</li>
<li>动态样式</li>
<li>操作表格</li>
<li>使用NodeList</li>
</ul>
<h2 id="11-DOM拓展"><a href="#11-DOM拓展" class="headerlink" title="11.DOM拓展"></a>11.DOM拓展</h2><h3 id="选择符API"><a href="#选择符API" class="headerlink" title="选择符API"></a>选择符API</h3><h3 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h3><h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><h3 id="专有扩展"><a href="#专有扩展" class="headerlink" title="专有扩展"></a>专有扩展</h3><h2 id="12-DOM2和DOM3"><a href="#12-DOM2和DOM3" class="headerlink" title="12.DOM2和DOM3"></a>12.DOM2和DOM3</h2><h3 id="DOM变化"><a href="#DOM变化" class="headerlink" title="DOM变化"></a>DOM变化</h3><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><h2 id="13-事件"><a href="#13-事件" class="headerlink" title="13.事件"></a>13.事件</h2><blockquote>
<p>可以使用监听器(或处理程序)来预订事件，是一种观察员模式的模型，支持页面行为和页面外观的松耦合</p>
</blockquote>
<h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><blockquote>
<p>描述从页面接收事件的顺序。IE的事件流是事件冒泡流，而网景的事件流是事件捕获流</p>
<ul>
<li>事件冒泡event bubbling<ul>
<li>事件开始时由最具体的元素接收(按钮)，然后逐级向上传播到较为不具体的节点(document)</li>
<li>所有现代浏览器都支持事件冒泡，IE9、Safari、Chrome、Firefox将事件一直冒泡到window</li>
</ul>
</li>
<li>事件捕获event capturing<ul>
<li>最先由不具体的节点接收到事件，具体的元素最后收到事件</li>
<li>目的：在事件到达目标节点之前捕获他</li>
<li>上述浏览器也都支持这种事件流模型，从window对象开始捕获事件</li>
</ul>
</li>
<li>DOM事件流<ul>
<li>三个阶段：事件捕获阶段(截获)、处于目标阶段(接收)、事件冒泡阶段(响应)</li>
<li>上述浏览器及更高版本都会在捕获阶段触发事件对象上的时间。所以捕获阶段、目标阶段都能操作事件</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h3><blockquote>
<p>响应某个事件的函数就叫做事件处理程序或事件监听器，通常以’on’开头，区别于事件名</p>
<ul>
<li>HTML事件处理程序<ul>
<li>使用与事件处理程序同名的属性来指定,属性值是可以被执行的JavaScript代码，可以是外部代码<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"showMessage()"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>注意</p>
<ul>
<li>存在一个局部变量event</li>
<li>this指定的是这个input元素</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>存在一个时差问题：在解析外部JavaScript代码之前就点击了按钮，会引发错误,解决方案如下</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"try&#123;showMessage();&#125;catch(ex)&#123;&#125;"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HTMl和JavaScript代码耦合</p>
</li>
<li><p>受不同浏览器环境影响</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>DOM0级事件处理程序</p>
<ul>
<li><p>将一个函数赋值给一个元素对象的引用的属性，属性名和事件处理程序同名</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优势</p>
<ul>
<li>简单</li>
<li>跨浏览器</li>
</ul>
</li>
<li><p>删除事件</p>
<ul>
<li><code>btn.onclick = null;</code></li>
</ul>
</li>
</ul>
</li>
<li><p>DOM2级事件处理程序</p>
<ul>
<li>定义了两种方法来处理事件：addEventListener()、removeEventListener()</li>
<li>参数<ul>
<li>第一个参数：要处理的事件名</li>
<li>第二个参数：作为事件处理程序的函数</li>
<li>第三个参数：布尔值，true表示捕获阶段调用函数；false表示冒泡阶段调用函数<ul>
<li>除非想在事件到达目标之前捕获事件，不然不用true<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.id</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'2'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, handler, <span class="literal">false</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'cilck'</span>, handler2, <span class="literal">false</span>)<span class="comment">//可以添加两个不同的click事件</span></span><br><span class="line">btn.removeEventListener(<span class="string">'click'</span>, handler, <span class="literal">false</span>)<span class="comment">//删除事件监听</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>IE事件处理程序</p>
<ul>
<li>实现了与DOM类似的两个方法：attachEvent()、detachEvent()</li>
<li>参数<ul>
<li>第一个参数：事件处理程序名(带’on-‘的)</li>
<li>第二个参数：事件处理程序函数</li>
</ul>
</li>
<li>和DOM事件处理程序的差异<ul>
<li>this指向window，DOM指向元素引用</li>
<li>添加两个事件时，顺序是后添加的先执行，DOM是代码顺序执行</li>
</ul>
</li>
<li>支持IE事件处理程序的有IE和Opera</li>
</ul>
</li>
<li><p>跨浏览器的事件处理程序</p>
<ul>
<li><p>手写一个兼容各个浏览器的事件处理程序，三类：DOM2级、DOM0级、IE</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">    addHandler:<span class="function"><span class="keyword">function</span>(<span class="params">ele, type, fun</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ele.addEventListener)&#123;</span><br><span class="line">            ele.addEventListener(type, fun, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ele.attachEvent) &#123;</span><br><span class="line">            ele.attachEvent(<span class="string">"on"</span> + type, fun);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ele[<span class="string">"on"</span>+type] = fun;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeHandler:<span class="function"><span class="keyword">function</span>(<span class="params">ele, type, fun</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ele.removeEventListener)&#123;</span><br><span class="line">            ele.removeEventListener(type, fun, <span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ele.detachEvent)&#123;</span><br><span class="line">            ele.detachEvent(<span class="string">"on"</span>+type, fun);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ele[<span class="string">"on"</span>+type] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">&#125;;</span><br><span class="line">EventUtil.addHandler(btn, <span class="string">'click'</span>, handler);</span><br><span class="line">EventUtil.removeHandler(btn, <span class="string">'click'</span>, handler);</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在几乎已经全部支持DOM2级事件了</p>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3></li>
</ul>
</li>
<li><p>DOM中的事件对象</p>
<ul>
<li>兼容DOM的浏览器会将一个event对象传入到事件处理程序中，一旦处理程序执行完成，event对象就会被销毁</li>
</ul>
</li>
<li><p>IE中的事件对象</p>
<ul>
<li>DOM0级：window.event</li>
<li>attachEvent: event</li>
</ul>
</li>
<li><p>跨浏览器的事件对象</p>
<h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3></li>
<li><p>UI事件</p>
</li>
<li><p>焦点事件</p>
</li>
<li><p>鼠标与滚轮事件</p>
</li>
<li><p>键盘与文本事件</p>
</li>
<li><p>复合事件</p>
</li>
<li><p>变动事件</p>
</li>
<li><p>HTML5事件</p>
</li>
<li><p>设备事件</p>
</li>
<li><p>触摸与手势事件</p>
<h3 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h3></li>
<li><p>事件委托</p>
</li>
<li><p>移除事件处理程序</p>
<h3 id="模拟事件"><a href="#模拟事件" class="headerlink" title="模拟事件"></a>模拟事件</h3></li>
<li><p>DOM中的事件模拟</p>
</li>
<li><p>IE中的事件模拟</p>
</li>
</ul>
<h2 id="20-Json"><a href="#20-Json" class="headerlink" title="20.Json"></a>20.Json</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><ul>
<li>简单值<ul>
<li>使用与JavaScript相同的语法，可以在Json中表示字符串、数值、布尔值和null。</li>
<li>JSON不支持JavaScript中的特殊值undefined</li>
</ul>
</li>
<li>对象<ul>
<li>对象作为一种复杂数据类型，表示的是一组无序的键值对儿。而每个键值对儿中的值可以是简单值，也可以是复杂数据类型的值</li>
</ul>
</li>
<li>数组<ul>
<li>数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型————简单值、对象或数组</li>
<li>JSON不支持变量、函数或对象实例，它就是一种表示结构化数据的格式，虽然与JavaScript中表示数据的某些语法相同，但它并不仅限于JavaScript的范畴。</li>
</ul>
</li>
</ul>
<h4 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h4><ul>
<li>数值：5</li>
<li>字符串：”Hello world!”<ul>
<li>JSON字符串必须使用双引号，单引号会导致语法错误</li>
</ul>
</li>
<li>布尔值和null也是有效的JSON形式</li>
</ul>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ul>
<li><p>Javascript中的对象字面量：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JSON表示上述对象的方式如下</p>
  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Nicholas"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>与Javascript的对象字面量相比，JSON对象有两个地方不一样</p>
<ul>
<li>首先，没有声明变量(JSON中没有变量的概念)</li>
<li>其次，没有末尾的分号</li>
</ul>
</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li>JavaScript中的数组字面量<ul>
<li>var values = [25,”h1”,true];</li>
</ul>
</li>
<li>JSON中<ul>
<li>[25,”h1”,true]</li>
</ul>
</li>
</ul>
<h3 id="解析与序列化"><a href="#解析与序列化" class="headerlink" title="解析与序列化"></a>解析与序列化</h3><h4 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h4><ul>
<li>早期的JSON解析器基本上就是使用JavaScript的eval()函数。由于JSON是JavaScript语法的子集，因此eval()函数可以解析、解释并返回JavaScript对象和数组</li>
<li>JSON对象有两个方法<ul>
<li>stringify()和parse()</li>
<li>在最简单的情况下，这两个方法分别用于把JavaScript对象序列化为JSON字符串和JSON字符串解析为原生JavaScript值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    title: <span class="string">"Professional JavaScript"</span>,</span><br><span class="line">    authors: [</span><br><span class="line">        <span class="string">"Nicholas C. Zakas"</span></span><br><span class="line">    ],</span><br><span class="line">    edition: <span class="number">3</span>,</span><br><span class="line">    year: <span class="number">2011</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book);</span><br><span class="line"><span class="keyword">var</span> bookCopy = <span class="built_in">JSON</span>.parse(jsonText);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="序列化选项"><a href="#序列化选项" class="headerlink" title="序列化选项"></a>序列化选项</h4><ul>
<li><p>JSON.stringify()除了要序列化的JavaScript对象外，还可以接收另外两个参数，这两个参数用于指定以不同的方式序列化JavaScript对象</p>
<ul>
<li>过滤器：可以是一个数组，也可以是一个函数</li>
<li>选项：表示是否在JSON字符串中保留缩进。</li>
</ul>
</li>
<li><p>过滤结果</p>
<ul>
<li><p>如果过滤器参数是数组，那么JSON.stringify()的结果中将只包含数组中列出的属性、</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    title: <span class="string">"Professional JavaScript"</span>,</span><br><span class="line">        authors: [</span><br><span class="line">            <span class="string">"Nicholas C. Zakas"</span></span><br><span class="line">        ],</span><br><span class="line">        edition: <span class="number">3</span>,</span><br><span class="line">        year: <span class="number">2011</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book,[<span class="string">"title, "</span>edition])</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果第二个参数是函数，传入的函数接收两个参数，属性名和属性值。根据属性名可以知道应该如何处理要序列化的对象中的属性。属性名只能是字符串，而在值并非键值对儿结构的值时，键名可以是空字符串。为了改变序列化对象的结果，函数返回的值就是相应键的值，不过要注意，如果函数返回了undefined，那么相应的属性会被忽略</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    title: <span class="string">"Professional JavaScript"</span>,</span><br><span class="line">        authors: [</span><br><span class="line">            <span class="string">"Nicholas C. Zakas"</span></span><br><span class="line">        ],</span><br><span class="line">        edition: <span class="number">3</span>,</span><br><span class="line">        year: <span class="number">2011</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book,<span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>)</span>&#123; </span><br><span class="line">     <span class="keyword">switch</span>(key)&#123; </span><br><span class="line">     <span class="keyword">case</span> <span class="string">"authors"</span>: </span><br><span class="line">     <span class="keyword">return</span> value.join(<span class="string">","</span>) </span><br><span class="line">     <span class="keyword">case</span> <span class="string">"year"</span>: </span><br><span class="line">     <span class="keyword">return</span> <span class="number">5000</span>; </span><br><span class="line">     <span class="keyword">case</span> <span class="string">"edition"</span>: </span><br><span class="line">     <span class="keyword">return</span> <span class="literal">undefined</span>; </span><br><span class="line">     <span class="keyword">default</span>: </span><br><span class="line">     <span class="keyword">return</span> value; </span><br><span class="line">     &#125; </span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>字符串缩进</p>
<ul>
<li>JSON.stringify()方法的第三个参数用于控制结果中的缩进和空白符。如果这个参数是一个数值，那它表示的是每个级别缩进的空格数</li>
<li>var jsonText = JSON.stringify(book, null, 4); </li>
<li>只要传入有效的控制缩进的参数值，结果字符串就会包含换行符。最大缩进空格为10，大于的会自动转换为10</li>
</ul>
</li>
<li><p>toJSON()方法</p>
<ul>
<li><p>原生对象有一个toJSON()方法，能够将JavaScript的date对象自动转换成ISO 8601日期字符串(与在Date对象上调用toISOString()的结果完全一样)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    title: <span class="string">"Professional JavaScript"</span>,</span><br><span class="line">    authors: [</span><br><span class="line">        <span class="string">"Nicholas C. Zakas"</span>,</span><br><span class="line">        <span class="string">"sss"</span></span><br><span class="line">    ],</span><br><span class="line">    edition: <span class="number">3</span>,</span><br><span class="line">    year: <span class="number">2011</span>,</span><br><span class="line">    toJSON: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book);</span><br></pre></td></tr></table></figure>
</li>
<li><p>toJSON()可以作为函数过滤器的补充，因此理解序列化的内部顺序十分重要</p>
<ul>
<li>如果存在toJSON()方法而且能通过它取得有效的值，则调用该方法。否则，返回对象本身。</li>
<li>如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是上一步返回的值</li>
<li>对上一步返回的每个值进行相应的序列化</li>
<li>如果提供了第三个参数，执行相应的格式化</li>
</ul>
</li>
</ul>
</li>
<li><p>解析选项</p>
<ul>
<li>JSON.parse()方法也可以接收另一个参数，该参数是一个函数，将在每个键值对儿上调用。为了区别JSON.stringify()接收的替换(过滤)函数(replacer)，这个函数被称为还原函数(reviver),但实际上这两个函数的签名是相同的————它们都接收两个参数，一个键一个值，而且都需要返回一个值。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"Professional JavaScript"</span>,</span><br><span class="line">    <span class="string">"authors"</span>: [</span><br><span class="line">        <span class="string">"Nicholas C. Zakas"</span>,</span><br><span class="line">        <span class="string">"sss"</span></span><br><span class="line">    ],</span><br><span class="line">    edition: <span class="number">3</span>,</span><br><span class="line">    year: <span class="number">2011</span>,</span><br><span class="line">    releaseDate: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2011</span>,<span class="number">11</span>,<span class="number">1</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bookCopy = <span class="built_in">JSON</span>.parse(jsonText, <span class="function"><span class="keyword">function</span>(<span class="params">key,value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key == <span class="string">"releaseDate"</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bookCopy.releaseDate.getFullYear());</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="21-Ajax与Comet"><a href="#21-Ajax与Comet" class="headerlink" title="21.Ajax与Comet"></a>21.Ajax与Comet</h2><blockquote>
<p>Ajax技术的核心是XMLHttpRequest对象，简称XHR对象。XHR为向服务器发送请求和解析服务器响应提供了流畅的接口，通过接口取得新数据，再通过DOM将新数据插入到页面中。名字里虽然带有XML，但是Ajax通信与数据格式无关，这个技术的就是为了无须刷新页面即可从服务器取得数据，不一定是XML数据。</p>
</blockquote>
<h3 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h3><ul>
<li><p>XHR对象落地史</p>
<ul>
<li><p>最早在IE5中(第一个引入XHR对象的浏览器)，XHR对象通过MSXML库中的一个ActiveX对象实现。因此IE中可能会遇到三种不同版本的XHR对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXHRInIE5</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.activeXString != <span class="string">"string"</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> versions = [<span class="string">"MSXML2.XMLHttp.6.0"</span>, <span class="string">"MSXML2.XMLHttp.3.0"</span>,</span><br><span class="line">                        <span class="string">"MSXML2.XMLHttp"</span>],</span><br><span class="line">                        i,len;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>, len=version.length; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">new</span> ActiveXObject(version[i]);</span><br><span class="line">                <span class="built_in">arguments</span>.callee.activeXString = version[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="built_in">arguments</span>.callee.activeXString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>IE7+、Firefox、Opera、Chrome、Safari支持原生XHR对象，可以通过使用XHR构造函数创建XHR对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXHR</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest != <span class="string">"undefinded"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> ActiveObject != <span class="string">"undefinded"</span>) &#123;</span><br><span class="line">        <span class="comment">//平稳退化，向IE7- 兼容</span></span><br><span class="line">        createXHRInIE5()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"No XHR object available."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> createXHR()</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>XHR的用法</p>
<ul>
<li><p>open()</p>
<ul>
<li><p>接受3个参数</p>
<ul>
<li>要发送的请求的类型</li>
<li>请求的URL:相对于执行代码的当前页面(也可以使用绝对路径)</li>
<li>表示是否异步发送请求的布尔值</li>
<li><code>xhr.open(&quot;get&quot;, &quot;example.php&quot;, false)</code></li>
</ul>
</li>
<li><p>说明</p>
<ul>
<li>open()方法并不会真正发送请求，而只是启动一个请求以备发送。要发送特定请求，open之后还要send<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">        xhr.open(<span class="string">"get"</span>, <span class="string">"example.txt"</span>, <span class="literal">false</span>);</span><br><span class="line">        xhr.send(<span class="literal">null</span>)</span><br><span class="line">        <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">      * URL不能跨域，只能向同一个域中使用相同端口和协议的URL发送请求。如果URL与启动请求页面有任何差别，都会引发安全错误</span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">  - send()</span></span><br><span class="line"><span class="string">    - 接收一个参数</span></span><br><span class="line"><span class="string">      -  参数是一个要作为请求主体发送的数据。如果不需要通过请求主体发送数据，则必须传入null，因为这个参数对有些浏览器来说是必需的。</span></span><br><span class="line"><span class="string">    - 原理：</span></span><br><span class="line"><span class="string">      - 调用send()之后，请求(是一次同步请求)就会被分派到服务器。JavaScript代码会等到服务器响应之后再继续执行，收到响应后，响应的数据会自动填充XHR对象的属性，相关的属性简介如下</span></span><br><span class="line"><span class="string">        * `</span>responseText<span class="string">`：作为响应主体被返回的文本</span></span><br><span class="line"><span class="string">        * `</span>responseXML<span class="string">`：如果响应的内容类型是"text/xml"或"application/xml",这个属性中将保存着响应数据的XML DOM 文档</span></span><br><span class="line"><span class="string">        * `</span>status<span class="string">`：响应的HTTP状态</span></span><br><span class="line"><span class="string">          * 一般将200作为成功的标志，此时responseText内容准备就绪</span></span><br><span class="line"><span class="string">          * 304，表示请求资源没有被修改，可以直接使用浏览器缓存的版本</span></span><br><span class="line"><span class="string">        * `</span>statusText<span class="string">`：HTTP状态的说明</span></span><br><span class="line"><span class="string">        `</span><span class="string">``</span>javascript</span><br><span class="line">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(<span class="string">"get"</span>, <span class="string">"example.txt"</span>, <span class="literal">false</span>)</span><br><span class="line">        xhr.send(<span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//建议通过检测status来决定下一步操作，不要依赖statusText</span></span><br><span class="line">        <span class="keyword">if</span>((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status ==<span class="number">304</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            alert(xhr.responseText)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">"Request was unsuccessful: "</span> + xhr.status)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">  - XHR.readyState属性</span></span><br><span class="line"><span class="string">    - 表示请求/响应过程的当前活动阶段</span></span><br><span class="line"><span class="string">      - 0：未初始化，尚未调用open方法</span></span><br><span class="line"><span class="string">      - 1：启动。已经调用open方法，尚未调用send方法</span></span><br><span class="line"><span class="string">      - 2：发送。已经调用send方法，但未接收到响应</span></span><br><span class="line"><span class="string">      - 3：接受。已接受到部分响应数据</span></span><br><span class="line"><span class="string">      - 4：完成。已接收到全部响应数据，而且已经可以在客户端使用了</span></span><br><span class="line"><span class="string">    - 每次活动阶段的改变，都会触发一次readystatechange事件</span></span><br><span class="line"><span class="string">      - 必须在调用open方法之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性</span></span><br><span class="line"><span class="string">        `</span><span class="string">``</span>javascript</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest</span><br><span class="line">        xhr.onstadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status ==<span class="number">304</span>) &#123;</span><br><span class="line">            </span><br><span class="line">                    alert(xhr.responseText)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    alert(<span class="string">"Request was unsuccessful: "</span> + xhr.status)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.open(<span class="string">"get"</span>, <span class="string">"example.txt"</span>, <span class="literal">false</span>)</span><br><span class="line">        xhr.send(<span class="literal">null</span>)</span><br><span class="line">        <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">  - abort()方法</span></span><br><span class="line"><span class="string">    - 在接收到响应之前可以调用abort方法来取消异步请求，即在`</span><span class="number">0</span>&lt;=readyState&lt;=<span class="number">2</span><span class="string">`的时候</span></span><br><span class="line"><span class="string">    - 使用abort方法之后，XHR对象会停止触发事件，而且不再允许访问任何与响应有关的对象属性。在终止请求之后，还应该对XHR对象进行解引用操作`</span>xhr = <span class="literal">null</span> <span class="string">`</span></span><br><span class="line"><span class="string">- HTTP头部信息</span></span><br><span class="line"><span class="string">  - 所有浏览器都会发送的头部信息</span></span><br><span class="line"><span class="string">    - Accept：浏览器能够处理的内容类型</span></span><br><span class="line"><span class="string">    - Accept-Charset：浏览器能够显示的字符集</span></span><br><span class="line"><span class="string">    - Accept-Encoding：浏览器能够处理的压缩编码</span></span><br><span class="line"><span class="string">    - Accept-Language：浏览器当前设置的语言</span></span><br><span class="line"><span class="string">    - Connection：浏览器与服务器之间连接的类型</span></span><br><span class="line"><span class="string">    - Cookie：当前页面设置的任何Cookie</span></span><br><span class="line"><span class="string">    - Host：发送请求的页面所在的域</span></span><br><span class="line"><span class="string">    - Referer：发送请求的页面的URI。正确拼写是referrer，只能将错就错</span></span><br><span class="line"><span class="string">    - User-Agent：浏览器的用户代理字符串</span></span><br><span class="line"><span class="string">  - setRequestHeader()</span></span><br><span class="line"><span class="string">    - 可以设置自定义的请求头部信息</span></span><br><span class="line"><span class="string">    - 两个参数</span></span><br><span class="line"><span class="string">      - 头部字段的名称和头部字段的值</span></span><br><span class="line"><span class="string">      - 必须在调用open之后且调用send之前调用setRequestHeader()</span></span><br><span class="line"><span class="string">    `</span><span class="string">``</span>javascript</span><br><span class="line">    xhr.open(<span class="string">"get"</span>, <span class="string">"example.txt"</span>, <span class="literal">false</span>)</span><br><span class="line">    xhr.setRequestHeader(<span class="string">"MyHeader"</span>,<span class="string">"MyValue"</span>)</span><br><span class="line">    xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>建议使用自定义头部信息，因为默认的头部信息和服务器之间可能存在某种响应关系</li>
</ul>
</li>
</ul>
</li>
<li><p>getResponseHeader(“MyHeader”)</p>
<ul>
<li>传入头部字段名称，取得相应的相应头部信息</li>
</ul>
</li>
<li><p>getAllResponseHeaders()</p>
<ul>
<li>取得一个包含所有头部信息的长字符串，以多行文本内容的形式返回</li>
</ul>
</li>
</ul>
</li>
<li><p>GET请求</p>
<ul>
<li>向服务器查询某些数据</li>
</ul>
</li>
<li><p>POST请求</p>
<ul>
<li>向服务器发送应该被保存的数据<h3 id="XMLHttpRequest-2级"><a href="#XMLHttpRequest-2级" class="headerlink" title="XMLHttpRequest 2级"></a>XMLHttpRequest 2级</h3></li>
</ul>
</li>
<li><p>FormData</p>
<ul>
<li><p>为序列化表单以及创建与表单格式相同的数据提供了便利</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData()</span><br><span class="line">data.append(<span class="string">"name"</span>, <span class="string">"lzm"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以直接向Formdata构造函数中传入表单元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">"post"</span>, <span class="string">"example.php"</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"user-info"</span>)</span><br><span class="line">xhr.send(<span class="keyword">new</span> FormData(form))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>超时设定</p>
<ul>
<li>XHR对象的timeout属性，表示请在等待响应对少毫秒之后就终止。在给timeout设定一个值之后，到了时间还没有响应就会调用ontimeout事件处理函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  xhr.open(<span class="string">"get"</span>, <span class="string">"example.php"</span>, <span class="literal">true</span>)</span><br><span class="line">  xhr.timeout = <span class="number">1000</span></span><br><span class="line">  xhr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(<span class="string">"timeout"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.send(<span class="literal">null</span>)</span><br><span class="line">  <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">- overrideMimeType()方法</span></span><br><span class="line"><span class="string">  - 用于重写XHR响应的MIME类型</span></span><br><span class="line"><span class="string">    `</span><span class="string">``</span>javascript</span><br><span class="line">    xhr.open(<span class="string">"get"</span>, <span class="string">"text.php"</span>, <span class="literal">true</span>)</span><br><span class="line">    xhr.overrideMimeType(<span class="string">"text/xml"</span>)</span><br><span class="line">    xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h3><ul>
<li><p>进度事件与种类</p>
<ul>
<li>定义了与客户端服务器通信有关的时间</li>
<li>共6个进度事件<ul>
<li>loadstart：在接收到响应数据的第一个字节时触发</li>
<li>progress：在接受响应期间不断地触发</li>
<li>error：在请求发生错误时触发</li>
<li>abort：在因为调用abort方法而终止连接时触发</li>
<li>load：在接受完整的响应数据时触发</li>
<li>loadend：在通信完成或者提前触发error、abort、load这类终止类型事件后触发</li>
</ul>
</li>
<li>生命周期<ul>
<li>首先会触发loadstart事件</li>
<li>接下来触发一次或多次progress事件</li>
<li>接下来触发error、abort、load事件中的一个</li>
<li>最后触发loadend事件</li>
</ul>
</li>
</ul>
</li>
<li><p>load事件</p>
<ul>
<li>Firefox引入load事件，用以替代readystatechange事件。因为响应接受完毕后触发load事件，因此没有必要去检查readyState属性</li>
<li>onload事件处理程序会接受一个event对象，event.target就指向XHR对象实例</li>
</ul>
</li>
<li><p>progress事件</p>
<ul>
<li>onprogress事件处理程序会接受一个event对象，除了包含target属性以外还包含额外的三个属性：lengthComputable、position(loaded)、totalSize(total);分别表示一个进度信息是否可用的布尔值，已接收到的字节数，根据Content-Length确定的预期字节数</li>
<li>必须在open之前添加onprogress事件处理程序<h3 id="跨域资源共享"><a href="#跨域资源共享" class="headerlink" title="跨域资源共享"></a>跨域资源共享</h3></li>
</ul>
</li>
<li><p>CORS(cross-origin resource sharing)</p>
<ul>
<li>通过XHR实现Ajax通信的一个主要限制，来源于跨域安全策略。默认XHR只能访问与包含它的页面同一个域中的资源，安全策略可以预防某些恶意行为</li>
<li>核心思想：使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是否成功<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    请求url：</span><br><span class="line">    Origin: http:<span class="comment">//leezhimeng.com</span></span><br><span class="line">    响应url：</span><br><span class="line">    Access-Control-Allow-Origin: http:<span class="comment">//leezhimeng.com</span></span><br><span class="line">    <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">- IE对CORS的实现</span></span><br><span class="line"><span class="string">  - </span></span><br><span class="line"><span class="string">- 其他浏览器对CORS的实现</span></span><br><span class="line"><span class="string">- Preflighted Requests</span></span><br><span class="line"><span class="string">- 带凭据的请求</span></span><br><span class="line"><span class="string">- 跨浏览器的CORS</span></span><br><span class="line"><span class="string">### 其他跨域技术</span></span><br><span class="line"><span class="string">- 图像Ping</span></span><br><span class="line"><span class="string">- JSONP</span></span><br><span class="line"><span class="string">- Comet</span></span><br><span class="line"><span class="string">- 服务器发送事件</span></span><br><span class="line"><span class="string">- Web Sockets</span></span><br><span class="line"><span class="string">- SSE与Web Sockets</span></span><br><span class="line"><span class="string">### 安全</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 22.高级技巧</span></span><br><span class="line"><span class="string">### 高级函数</span></span><br><span class="line"><span class="string">- 安全的类型检测</span></span><br><span class="line"><span class="string">  - 因为typeof操作符在检测引用类型时不够详细，instanceof操作符在存在多个全局作用域的情况下也会有很多问题</span></span><br><span class="line"><span class="string">  - 使用Object原生的toString()</span></span><br><span class="line"><span class="string">  `</span><span class="string">``</span>javascript</span><br><span class="line">  <span class="comment">//假设toString没有被篡改的情况下</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) == <span class="string">"[object Array]"</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//检测是否有原生的JSON对象</span></span><br><span class="line">  <span class="keyword">var</span> isNativeJSON = <span class="built_in">window</span>.JSON &amp;&amp; <span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">JSON</span>) == <span class="string">"[object JSON]"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h3 id="防篡改对象"><a href="#防篡改对象" class="headerlink" title="防篡改对象"></a>防篡改对象</h3><h3 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h3><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><h3 id="拖放"><a href="#拖放" class="headerlink" title="拖放"></a>拖放</h3></li>
</ul>
<h2 id="23-离线应用与客户端存储"><a href="#23-离线应用与客户端存储" class="headerlink" title="23.离线应用与客户端存储"></a>23.离线应用与客户端存储</h2><h3 id="离线监测"><a href="#离线监测" class="headerlink" title="离线监测"></a>离线监测</h3><h3 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a>应用缓存</h3><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><ul>
<li>Cookie</li>
<li>IE用户数据</li>
<li>Web存储机制</li>
<li>IndexedDB</li>
</ul>
<h2 id="24-最佳实践"><a href="#24-最佳实践" class="headerlink" title="24.最佳实践"></a>24.最佳实践</h2><h3 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h3><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="Symbol和Symbol属性"><a href="#Symbol和Symbol属性" class="headerlink" title="Symbol和Symbol属性"></a>Symbol和Symbol属性</h2><ul>
<li>设计私有名称原本是为了让开发者们创建非字符串属性名称，最终演变成了Symbol<h3 id="创建Symbol"><a href="#创建Symbol" class="headerlink" title="创建Symbol"></a>创建Symbol</h3><h3 id="Symbol的使用方法"><a href="#Symbol的使用方法" class="headerlink" title="Symbol的使用方法"></a>Symbol的使用方法</h3><h3 id="Symbol共享体系"><a href="#Symbol共享体系" class="headerlink" title="Symbol共享体系"></a>Symbol共享体系</h3><h3 id="Symbol与类型强制转换"><a href="#Symbol与类型强制转换" class="headerlink" title="Symbol与类型强制转换"></a>Symbol与类型强制转换</h3><h3 id="Symbol属性检索"><a href="#Symbol属性检索" class="headerlink" title="Symbol属性检索"></a>Symbol属性检索</h3><h3 id="通过"><a href="#通过" class="headerlink" title="通过"></a>通过</h3></li>
</ul>
<h2 id="7-Set集合和Map集合"><a href="#7-Set集合和Map集合" class="headerlink" title="7.Set集合和Map集合"></a>7.Set集合和Map集合</h2><ul>
<li><p>Set集合是一种无重复元素的列表，常被用来检测给定的值是否在集合中</p>
</li>
<li><p>Map集合时一种多组键值对的列表，常被用于缓存频繁取用的数据，用来获取已存的信息。</p>
<h3 id="ES5中的Set集合和Map集合"><a href="#ES5中的Set集合和Map集合" class="headerlink" title="ES5中的Set集合和Map集合"></a>ES5中的Set集合和Map集合</h3></li>
<li><p>用对象的属性模拟set和map</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set:查看给定的值是否存在</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = Object.create(null)</span><br><span class="line"><span class="keyword">set</span>.foo = true //能够表达布尔类型的值都可以，即大部分时候只要赋值了，就是真，即存在</span><br><span class="line">//检测属性是否存在</span><br><span class="line">if(<span class="keyword">set</span>.foo)&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//map:获取已存的信息</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">map.foo = <span class="string">'jimmy'</span></span><br><span class="line"><span class="comment">//获取已存的信息</span></span><br><span class="line"><span class="keyword">var</span> name = map.foo</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述解决方案存在的问题</p>
<ul>
<li><p>map的键名会自动转换成字符串</p>
<ul>
<li>用数字的话会转换成字符串，</li>
<li>键名用对象的话会转换成<code>&#39;[object OBject]&#39;</code>,</li>
<li>键名用数组的话会转换成对应的字符串，如空数组转换成<code>&quot;&quot;</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    map[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    map[&#123;&#125;] = <span class="number">2</span></span><br><span class="line">    map[[]] = <span class="number">3</span>    </span><br><span class="line">    map[<span class="string">"1"</span>] <span class="comment">// 1  &#123;1 ：1&#125;</span></span><br><span class="line">    map[&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;] <span class="comment">//2  &#123;"[object Object]" : 2&#125;</span></span><br><span class="line">    map[<span class="string">""</span>] <span class="comment">// 3  &#123;"" : 3&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">  - set的应用场景问题</span></span><br><span class="line"><span class="string">    - set本身的意思是检测元素是否存在于集合中</span></span><br><span class="line"><span class="string">    - ES5的实现是set.foo是否为假值来判断foo是否存在于set中，但0是假值，但确实也是存在的</span></span><br><span class="line"><span class="string">    `</span><span class="string">``</span>javascript</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">set</span> = Object.create(null)</span><br><span class="line">    <span class="keyword">set</span>.foo = 0</span><br><span class="line">    if(<span class="keyword">set</span>.foo)&#123;</span><br><span class="line">        <span class="comment">//set.foo === false，不会执行，但0确实是存在的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(foo <span class="keyword">in</span> <span class="keyword">set</span>)&#123;</span><br><span class="line">        <span class="comment">//由于set原型为null，用in稳妥一点，</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// in运算符</span></span><br><span class="line">    <span class="comment">// 不需要读取对象的值就可以判断属性是否在对象中</span></span><br><span class="line">    <span class="comment">// in会探索对象的原型，当对象原型为null时使用这个方法比较稳妥</span></span><br><span class="line">    <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">### ES6中的Set集合</span></span><br><span class="line"><span class="string">- ES6中的Set集合是一种有序列表，包含一些相互独立的非重复值</span></span><br><span class="line"><span class="string">- 创建Set集合并添加元素</span></span><br><span class="line"><span class="string">  - new Set()</span></span><br><span class="line"><span class="string">    - 可以直接传入可迭代类型，返回一个去重了的set</span></span><br><span class="line"><span class="string">  - set.add()</span></span><br><span class="line"><span class="string">    - add一个已存在的值，会忽视这次操作</span></span><br><span class="line"><span class="string">  - set.size</span></span><br><span class="line"><span class="string">  - set.has()</span></span><br><span class="line"><span class="string">- 移除元素</span></span><br><span class="line"><span class="string">  - set.delete()</span></span><br><span class="line"><span class="string">  - set.clear()</span></span><br><span class="line"><span class="string">- set的forEach()方法</span></span><br><span class="line"><span class="string">  - 第一个参数，回调函数</span></span><br><span class="line"><span class="string">    - 第一个参数，索引。索引就是值</span></span><br><span class="line"><span class="string">    - 第二个参数，索引。因为set没有键名，为了合租的forEach差别不太大，就用来一个和第一个参数相同的值</span></span><br><span class="line"><span class="string">    - 第三个参数，set本身</span></span><br><span class="line"><span class="string">  - 第二个参数，this</span></span><br><span class="line"><span class="string">- Set转换为数组</span></span><br><span class="line"><span class="string">  - 数组转set只需给Set构造函数传入数组即可，外加去重功能</span></span><br><span class="line"><span class="string">  - 将set转数组需要用到展开运算法`</span>...<span class="string">`</span></span><br><span class="line"><span class="string">###  Weak Set集合</span></span><br><span class="line"><span class="string">  - Set是强引用的Set集合，容易造成内存泄漏，即保存了一些已经再也不会用的变量导致垃圾清理器没有清理掉这些垃圾</span></span><br><span class="line"><span class="string">  `</span><span class="string">``</span>javascript</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line">  a = &#123;b:<span class="number">1</span>&#125;</span><br><span class="line">  <span class="keyword">set</span>.add(a) //将引用a的值&#123;b:<span class="number">1</span>&#125;加入<span class="keyword">set</span>集合，<span class="keyword">set</span>对a的强引用</span><br><span class="line">  a = null //清除了a对&#123;b:<span class="number">1</span>&#125;的强引用，此时a应该没啥用了</span><br><span class="line">  <span class="keyword">set</span>.size // 1 </span><br><span class="line">  b = [...<span class="keyword">set</span>][0] //能够重新找回这个值</span><br><span class="line">  [...<span class="keyword">set</span>][0].b = 2 //然后我们修改这个对象</span><br><span class="line">  b //&#123;b:<span class="number">2</span>&#125; b也会跟着被修改</span><br><span class="line">  <span class="comment">//由于set还保存着对a的强引用，导致a不会被垃圾清理器清理掉</span></span><br><span class="line">  <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">  - 创建Weak Set集合</span></span><br><span class="line"><span class="string">    - add()</span></span><br><span class="line"><span class="string">    - has()</span></span><br><span class="line"><span class="string">    - delete()</span></span><br><span class="line"><span class="string">    - new WeakSet()</span></span><br><span class="line"><span class="string">      - 只接受一个参数，一个可迭代对象，对象的元素不能是原始类型的值</span></span><br><span class="line"><span class="string">        `</span><span class="string">``</span>javascript</span><br><span class="line">        <span class="keyword">let</span> weakSet = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([&#123;&#125;]) <span class="comment">//正确，可迭代对象数组中的元素是对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">WeakSet</span>(&#123;&#125;) <span class="comment">//error，&#123;&#125;不是可迭代对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">WeakSet</span>([<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">//error,可迭代对象数组中的元素是原始类型的值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>两种Set类型的主要区别</p>
<ul>
<li>Weak Set保存着对象值的弱引用，当该集合的弱引用是对象唯一的引用时，该对象会被内存释放<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> <span class="keyword">set</span> = new WeakSet()</span><br><span class="line">    key = &#123;a:<span class="number">1</span>&#125;  <span class="comment">//key是对象值&#123;a:1&#125;的一个强引用</span></span><br><span class="line">    <span class="keyword">set</span>.add(key) //通过添加强引用key的方式，将对象值加入<span class="keyword">set</span></span><br><span class="line">    key = null  //解除key对对象值的强引用</span><br><span class="line">    //由于weakset类型的<span class="keyword">set</span>是key的唯一引用了，所以key被释放了</span><br><span class="line">    //由于key已经没有了，我们就无法展示测试，JavaScript引擎一定会正确移除最后一个弱引用(<span class="keyword">set</span>对key的引用)</span><br><span class="line">    ``` </span><br><span class="line">    - 在WeakSet构造函数或者实例的方法中传入原始类型的值，都会报错</span><br><span class="line">    - weakset不可迭代，不能用于for-of，也不能用拓展运算符展开</span><br><span class="line">    - 不暴露任何迭代器，即没有keys()和values()，所以无法通过程序本身来检测其中的内容</span><br><span class="line">    - 不支持forEach()</span><br><span class="line">    - 不支持size</span><br><span class="line">    - 对用户的可见度极低</span><br><span class="line">### ES6中的Map集合</span><br><span class="line">- ES6的Map类型是一种存储多组键值对的有序列表，键名和键值支持所有数据类型，等价性判断是由Object.is实现的，与对象不太一样的是，对象的属性名总会被强制转换成字符串</span><br><span class="line">- 给Map集合添加新元素</span><br><span class="line">  - <span class="keyword">set</span>(key, value)</span><br><span class="line">  - <span class="keyword">get</span>(key)</span><br><span class="line">- map支持的方法</span><br><span class="line">  - has(key)</span><br><span class="line">  - delete(key)</span><br><span class="line">  - clear()</span><br><span class="line">  - map.size</span><br><span class="line">- map的初始化方法</span><br><span class="line">  - 构造函数中接受一个数组(也可以是别的可迭代对象，比如字符串)作为参数，数组中的每个元素都是一个子数组，每个子数组包含两个元素，第一个元素是键，第二个元素是对应的值</span><br><span class="line">  ```javascript</span><br><span class="line">  //为什么传入的键值对要放在数组中，因为他们刚开始可能都是各个类型，为了确保他们在传入Map构造函数之前都没有被以外的强转成字符串，放在数组中是很安全的</span><br><span class="line">  let map = new Map([["name", "jimmy"], ["age", 20]])</span><br><span class="line">  map.size //2</span><br><span class="line">  ``` </span><br><span class="line">- map集合的forEach方法</span><br><span class="line">  - 回调函数接受三个参数</span><br><span class="line">    - 值</span><br><span class="line">    - 键</span><br><span class="line">    - map本身</span><br><span class="line">### Weak Map集合</span><br><span class="line">- WeakMap是弱引用的Map集合</span><br><span class="line">- WeakMap的键名必须是一个对象，集合中保存的是这些对象的弱引用，如果在弱引用之外不存在别的强引用了，这个对象会被垃圾回收装置自动回收，同时会移除集合中的键值对</span><br><span class="line">- WeakMap的键值保存的值如果是对象则是强引用，解除引用后不会触发垃圾回收机制</span><br><span class="line">    ```javascript</span><br><span class="line">    let weakMap = new WeakMap()</span><br><span class="line">    a = &#123;&#125;</span><br><span class="line">    b = &#123;&#125;</span><br><span class="line">    weakMap.set(a, b)</span><br><span class="line">    b = <span class="literal">null</span></span><br><span class="line">    <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">- WeakMap使用方式</span></span><br><span class="line"><span class="string">  - 和Map的关系就像WeakSet与Set的使用方式和使用限制一样</span></span><br><span class="line"><span class="string">- 使用WeakMap存储私有对象</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 8.迭代器(Iterator)和生成器(Generator)</span></span><br><span class="line"><span class="string">- 循环语句的问题：存在多层循环嵌套的时候，代码复杂度大大增加</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">###  什么是迭代器</span></span><br><span class="line"><span class="string">- 是一种特殊的对象</span></span><br><span class="line"><span class="string">- 有一个next方法，每次调用都会返回一个对象，对象有两个属性：value和done</span></span><br><span class="line"><span class="string">- 迭代器内部保存有一个指针，用来指向当前集合中的位置，每次调用next方法，都会返回下一个可用的值(对象)</span></span><br><span class="line"><span class="string">  `</span><span class="string">``</span>javascript</span><br><span class="line">  <span class="comment">//ES5手写创建迭代器</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createIterator</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">      <span class="comment">//return 一个有next方法的对象</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">          next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> done = (i &gt;= arr.length)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> value = done ? <span class="literal">undefined</span> : arr[i++]</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//return 一个有done和value属性的对象</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                done: done,</span><br><span class="line">                value: value</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> iterator = createIterator([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">  iterator.next()   <span class="comment">//&#123; value: 1, done: false &#125;</span></span><br><span class="line">  iterator.next()   <span class="comment">//&#123; value: 2, done: false &#125;</span></span><br><span class="line">  iterator.next()   <span class="comment">//&#123; value: 3, done: false &#125;</span></span><br><span class="line">  iterator.next()   <span class="comment">//&#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//似乎还有一点复杂，两个地方用到了闭包，于是引出了生成器</span></span><br><span class="line">  <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">###  什么是生成器</span></span><br><span class="line"><span class="string">- 是一种返回迭代器的函数，通过*号来表示函数是一个生成器，会用到新关键字yield来指定调用迭代器的next方法时返回值及返回顺序</span></span><br><span class="line"><span class="string">  - 匿名函数，星号加在（建议紧贴）`</span><span class="function"><span class="keyword">function</span>`和小括号之间`<span class="title">function</span> *(<span class="params"></span>) </span>&#123;&#125;<span class="string">`</span></span><br><span class="line"><span class="string">  - 具名函数，星号加在（建议紧贴）`</span><span class="function"><span class="keyword">function</span>`和函数名之间`<span class="title">function</span> *<span class="title">name</span>(<span class="params"></span>) </span>&#123;&#125;<span class="string">`</span></span><br><span class="line"><span class="string">  - 函数作为对象方法简写,星号加在（建议紧贴）函数名之前`</span>*name() &#123;&#125;<span class="string">`</span></span><br><span class="line"><span class="string">    `</span><span class="string">``</span>javascript</span><br><span class="line">    <span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'round 2'</span>)</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'round 3'</span>)</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> iterator = createIterator()</span><br><span class="line">    iterator.next() <span class="comment">//&#123; value: 1, done: false &#125;</span></span><br><span class="line">    <span class="comment">//在执行第二次next()之前，不会打印round 2</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>生成器函数的一个很重要的细节：终止函数执行机制</p>
<ul>
<li>每当执行完一条yield语句后函数就会自动停止执行，直到再次调用next方法</li>
</ul>
</li>
<li><p>yield的使用限制</p>
<ul>
<li>yield只能存在于生成器函数内部的作用域，不能存在于生成器的内部函数中。同return相似，return放在嵌套的内部函数中，只会return内部函数，并不会渗透出来return外部函数</li>
</ul>
</li>
<li><p>yield用法</p>
<ul>
<li><code>yield 基本类型</code>一个next搞定</li>
<li><code>yield *可迭代对象</code>数组、set、map、字符串，需要多个next一个元素一个元素输出</li>
<li><code>yield 生成器</code>遍历生成器中的yield，需要多个next</li>
</ul>
</li>
<li><p>生成器函数表达式</p>
<ul>
<li>只需在function和参数小括号中间加上*号，不能用箭头函数来创建生成器</li>
</ul>
</li>
<li><p>生成器作为对象的方法</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    createIterator: <span class="function"><span class="keyword">function</span> *(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; item.length ; i++) &#123;</span><br><span class="line">            <span class="keyword">yield</span> item[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = o.createIterator([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6函数简写</span></span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    *createIterator(item) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; item.length ; i++) &#123;</span><br><span class="line">            <span class="keyword">yield</span> item[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = o.createIterator([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="可迭代对象和for-of循环"><a href="#可迭代对象和for-of循环" class="headerlink" title="可迭代对象和for-of循环"></a>可迭代对象和for-of循环</h3><ul>
<li><p>可迭代对象</p>
<ul>
<li>具有Symbol.iterator属性的对象，所有的集合对象和字符串都是可迭代对象</li>
<li>Symbol.iterator中存储着一个可以返回一个作用于附属对象的迭代器的函数<ul>
<li><code>可迭代对象[Symbol.iterator]()</code></li>
</ul>
</li>
<li>生成器会默认为Symbol.iterator属性赋值，因此所有通过生成器创建的迭代器都是可迭代对象</li>
</ul>
</li>
<li><p>for-of</p>
<ul>
<li>只关注要处理的内容，即可迭代对象的值，而不用关注索引了(for-in就是关注索引)</li>
<li>原理：每循环一次，执行一次可迭代对象的next方法，并将迭代器返回结果对象的value属性赋值给一个变量，循环执行这一个过程，直至done为true(迭代器内部return会直接将done变成true，无论有没有后续yield)</li>
<li>for-of用于不可迭代对象会抛出错误</li>
</ul>
</li>
<li><p>访问默认迭代器</p>
<ul>
<li><p>通过Symbol.iterator来访问对象默认的迭代器</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">//js引擎处理for-of也会有类似的处理过程</span></span><br><span class="line"><span class="keyword">let</span> iterator = values[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"></span><br><span class="line">iterator.next() <span class="comment">//&#123; value: 1, done: false&#125;</span></span><br></pre></td></tr></table></figure></code></pre></li>
<li><p>检测对象是否是可迭代对象</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">typeof</span> object[<span class="built_in">Symbol</span>.iterator] === <span class="string">'function'</span>)</span><br><span class="line">    <span class="comment">//return Object.prototype.toString.call(object[Symbol.iterator] === '[object Function]')</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li>
</ul>
</li>
<li><p>创建可迭代对象</p>
<ul>
<li>默认情况下，开发者定义的对象都不是可迭代对象</li>
<li>如果给Symbol.iterator属性添加一个生成器，则可以将其变为可迭代对象<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterableObject = &#123;</span><br><span class="line">    arr: [],</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> <span class="keyword">this</span>.arr) &#123;</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line">        &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">iterableObject.arr.push(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> iterableObject) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure></code></pre></li>
</ul>
</li>
</ul>
<h3 id="内建迭代器"><a href="#内建迭代器" class="headerlink" title="内建迭代器"></a>内建迭代器</h3><ul>
<li><p>集合对象迭代器</p>
<ul>
<li>集合对象有3种类型：数组、map、set</li>
<li>都内建了三种迭代器<ul>
<li>entries()   返回一个迭代器，其value为数组存储的键值对</li>
<li>values()    返回一个迭代器，其value为集合的值</li>
<li>keys()      返回一个迭代器，其value为集合的键</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串迭代器</p>
</li>
<li><p>NodeList迭代器</p>
<h3 id="展开运算符与非数组可迭代对象"><a href="#展开运算符与非数组可迭代对象" class="headerlink" title="展开运算符与非数组可迭代对象"></a>展开运算符与非数组可迭代对象</h3></li>
<li><p>展开运算符可以将任意非数组可迭代对象转为数组</p>
<ul>
<li><code>arr = [...set]</code></li>
<li><code>arr = [...map]</code></li>
<li><code>arr = [0, ...arr1, ...arr2]</code></li>
<li><code>arr = [...string]</code><h3 id="高级迭代器功能"><a href="#高级迭代器功能" class="headerlink" title="高级迭代器功能"></a>高级迭代器功能</h3></li>
</ul>
</li>
<li><p>给迭代器传递参数</p>
<ul>
<li>如果给next方法传递参数，则这个参数就会替代生成器内部上一条yield的返回值<ul>
<li>第一次调用next方法时传递参数没有意义，因为不存在上一条yield语句<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> second = <span class="keyword">yield</span> first + <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> second + <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> iterator = createIterator()</span><br><span class="line">    iterator.next() <span class="comment">//&#123; value: 1, done: false&#125;</span></span><br><span class="line">    iterator.next(<span class="number">4</span>) <span class="comment">//&#123; value: 6, done: false&#125;</span></span><br><span class="line">    iterator.next(<span class="number">5</span>) <span class="comment">//&#123; value: 8, done: false&#125;</span></span><br><span class="line">    <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">- 在迭代器中抛出错误</span></span><br><span class="line"><span class="string">  - 迭代器调用throw方法,可以使用try-catch捕获</span></span><br><span class="line"><span class="string">    `</span><span class="string">``</span> JavaScript</span><br><span class="line">    <span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> second</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            second = <span class="keyword">yield</span> first + <span class="number">2</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(ex) &#123;</span><br><span class="line">            second = first + <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> second + <span class="number">3</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> iterator = createIterator()</span><br><span class="line">    iterator.next()     <span class="comment">//&#123; value: 1, done: false&#125;</span></span><br><span class="line">    iterator.next(<span class="number">4</span>)    <span class="comment">//&#123; value: 6, done: false&#125;</span></span><br><span class="line">    iterator.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'bom'</span>))    <span class="comment">//&#123; value: 9, done: false&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>生成器返回语句</p>
<ul>
<li>默认最后一次有意义的调用next方法的value是undefined，可以通过return的方式为最后一次调用赋值，但再次调用next()的value依然是undefined</li>
<li>for-of循环不会读到return的返回值，因为done变成true时就马上终止循环</li>
</ul>
</li>
<li><p>委托生成器 </p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> *<span class="title">createNumberIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> *<span class="title">createRepeatIterator</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count ; i++) &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">'repeat'</span> + i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> *<span class="title">createCombinedIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">yield</span> *createNumberIterator()</span><br><span class="line">        <span class="keyword">yield</span> result</span><br><span class="line">        <span class="keyword">yield</span> *<span class="string">'rep'</span></span><br><span class="line">        <span class="keyword">yield</span> *createRepeatIterator(result)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'done'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> iterator = createCombinedIterator()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(iterator.next())    <span class="comment">//&#123; value: 1, done: false&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(iterator.next())    <span class="comment">//&#123; value: 2, done: false&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(iterator.next())    <span class="comment">//&#123; value: 'r', done: false&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(iterator.next())    <span class="comment">//&#123; value: 'e', done: false&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(iterator.next())    <span class="comment">//&#123; value: 'p', done: false&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(iterator.next())    <span class="comment">//&#123; value: 'repeat0', done: false&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(iterator.next())    <span class="comment">//&#123; value: 'repeat1', done: false&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(iterator.next())    <span class="comment">//&#123; value: 'done', done: true&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(iterator.next())    <span class="comment">//&#123; value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">###  异步任务执行</span></span><br><span class="line"><span class="string">- 简单任务执行器</span></span><br><span class="line"><span class="string">    `</span><span class="string">``</span>javascript</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskrun</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> iter = taskrun()</span><br><span class="line">        <span class="keyword">let</span> result = iter.next()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!result.done)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(result.value)</span><br><span class="line">                result = iter.next()</span><br><span class="line">                step()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*while(!result.done)&#123;</span></span><br><span class="line"><span class="comment">               console.log(result.value)</span></span><br><span class="line"><span class="comment">                result = iter.next() </span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	    step()</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> *<span class="title">generator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run(generator)</span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">- 向任务执行器传递数据</span></span><br><span class="line"><span class="string">    `</span><span class="string">``</span>javascript</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!result.done)&#123;</span><br><span class="line">            result = iter.next(result.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> *<span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">        <span class="built_in">console</span>.log(first) <span class="comment">//1</span></span><br><span class="line">        first = <span class="keyword">yield</span> first + <span class="number">2</span></span><br><span class="line">        <span class="built_in">console</span>.log(first) <span class="comment">// 3 </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>异步任务执行器</p>
<ul>
<li>当<code>iterator.next().value</code>是一个函数时，任务执行器会先执行这个函数再将结果传入next方法</li>
</ul>
</li>
</ul>
<h2 id="9-JavaScript中的类"><a href="#9-JavaScript中的类" class="headerlink" title="9.JavaScript中的类"></a>9.JavaScript中的类</h2><h3 id="ES5中的近类结构"><a href="#ES5中的近类结构" class="headerlink" title="ES5中的近类结构"></a>ES5中的近类结构</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'jimmy'</span>)</span><br><span class="line">person.getName()<span class="comment">//jimmy</span></span><br><span class="line">person <span class="keyword">instanceof</span> Person <span class="comment">//true</span></span><br><span class="line">person <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h3><ul>
<li>基本的类声明语法：class关键字，用来声明类。类声明时基于已有自定义类型声明的语法糖</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">//等价于Person构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等价于Person.prototype.sayName</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">'jimmy'</span>)</span><br><span class="line">person.sayName()<span class="comment">//jimmy</span></span><br><span class="line"><span class="keyword">typeof</span> PersonClass <span class="comment">//function</span></span><br><span class="line"><span class="comment">//PersonClass.prototype只可读，因为类属性不可被赋予新值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>类语法和自定义类型的差异<ol>
<li>提升：函数声明可以提升，类声明不能提升，与let类似</li>
<li>严格模式：类声明中的代码运行在严格模式之下，无法强行让代码脱离严格模式执行</li>
<li>可枚举方法：自定义类型中可通过Object.defindProperty()手动指定方法是否枚举(默认可枚举)，类中，所有方法都不可枚举</li>
<li>构造函数<code>[[Construct]]</code>：所有类中都有一个[[Construct]]内部方法，只有有[[Construct]]的方法才能使用new</li>
<li>new关键字：类的构造函数只能用new调用（new.target !== “undefined”）</li>
<li>类名：类中修改类名会导致程序报错</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6之前的语法实现class</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.外部可以修改类名，用函数表达式的方式将PersonType修改成了PersonType2</span></span><br><span class="line"><span class="keyword">let</span> PersonType2 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>     <span class="comment">//2.严格模式</span></span><br><span class="line">    <span class="comment">//6.内部不可以修改类名，用const</span></span><br><span class="line">    <span class="keyword">const</span> PersonType = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//4.类中有一个构造函数的内部方法，只有有构造函数的方法才能使用new</span></span><br><span class="line">        <span class="comment">//5.构造函数只能使用new调用</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">new</span>.target === <span class="string">"undefined"</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"please use new"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(PersonType.prototype, <span class="string">"sayName"</span>, &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//5.sayName方法不能用new调用</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">new</span>.target !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"please dont use new"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//3.类中所有方法不可枚举</span></span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PersonType</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">//1.不能提升，同let拥有暂时性死区</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonType2(<span class="string">"jimmy"</span>)</span><br><span class="line">person.sayName() <span class="comment">// jimmy</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6 class关键字</span></span><br><span class="line"><span class="comment">//6.内部修改不了类名，外部可以</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        foo = <span class="string">"refoo"</span><span class="comment">//报错 assignment to constant variable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo = <span class="string">"refoo"</span><span class="comment">//修改成功</span></span><br></pre></td></tr></table></figure>

<h3 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h3><ul>
<li><p>基本类表达式语法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonType2 = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> PersonType2 <span class="comment">//function</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>命名类表达式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上述ES6之前语法实现的class等价于</span></span><br><span class="line"><span class="keyword">let</span> PersonType2 = <span class="class"><span class="keyword">class</span> <span class="title">PersonType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> PersonType <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">typeof</span> PersonType2 <span class="comment">//function</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="作为一等公民的类"><a href="#作为一等公民的类" class="headerlink" title="作为一等公民的类"></a>作为一等公民的类</h3><ul>
<li>一等公民：能够传入函数，也能被当做值从函数返回，也可以被赋值给变量</li>
<li>JavaScript函数是一等公民，ES6的class也被设计成一等公民<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类被当做参数传入函数,且被当做返回值返回</span></span><br><span class="line"><span class="keyword">let</span> createClass = <span class="function"><span class="keyword">function</span>(<span class="params">classDef, name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> classDef(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = createClass(<span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">"jimmy"</span>)</span><br><span class="line"></span><br><span class="line">obj.sayName()<span class="comment">//jimmy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//立即调用类</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="string">"jimmy"</span>)</span><br><span class="line">person.sayName()<span class="comment">//jimmy</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//将element元素的innerHTML方法委托给了类的html属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">		<span class="keyword">this</span>.element = element</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建访问器属性html</span></span><br><span class="line">	<span class="keyword">get</span> html() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">set</span> html(value) &#123;</span><br><span class="line">		<span class="keyword">this</span>.element.innerHTML = value</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(CustomHTMLElement.prototype, <span class="string">"html"</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">"get"</span> <span class="keyword">in</span> descriptor <span class="comment">//true 'in'只要是实例或者属性都返回true</span></span><br><span class="line"><span class="string">"set"</span> <span class="keyword">in</span> descriptor <span class="comment">//true </span></span><br><span class="line">descriptor.enumberable <span class="comment">// false  类里面的方法都是不可枚举的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&lt;div id="visitor"&gt; 123 &lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> node = <span class="keyword">new</span> CustomHTMLElement(<span class="built_in">document</span>.getElementById(<span class="string">"visitor"</span>))</span><br><span class="line">node.html <span class="comment">//123</span></span><br><span class="line">node.html = <span class="number">1234</span> <span class="comment">// &lt;div id="visitor"&gt;1234&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//用es6以前的方法实现上述类的访问器属性</span></span><br><span class="line"><span class="keyword">let</span> CustomHTMlElement = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//严格模式</span></span><br><span class="line"><span class="meta">    "use strict"</span></span><br><span class="line">    <span class="comment">//创建构造函数（1.内部不能修改类名，2.必须用new调用）</span></span><br><span class="line">    <span class="keyword">const</span> CustomHTMLElement = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建访问器属性（1.不可枚举）</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(CustomHTMLElement.prototype, <span class="string">"html"</span>, &#123;</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        <span class="keyword">get</span>: function() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function(value) &#123; </span><br><span class="line">            <span class="keyword">this</span>.element.innerHTML = value</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> CustomHTMLElement</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h3 id="可计算成员名称"><a href="#可计算成员名称" class="headerlink" title="可计算成员名称"></a>可计算成员名称</h3><ul>
<li>同对象字面量：类方法和访问器属性也支持可计算名称<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName = <span class="string">"say"</span></span><br><span class="line"><span class="keyword">let</span> visitorName = <span class="string">"html"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    [methodName + <span class="string">"Name"</span>]() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> [visitorName]()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> [visitorName](value)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="生成器方法"><a href="#生成器方法" class="headerlink" title="生成器方法"></a>生成器方法</h3><ul>
<li>如果类用来表示值的集合，可以用Symbol.iterator定义生成器的方法为它添加一个默认的迭代器</li>
<li>这样的类的实例可直接用于for-of循环和展开运算符，但是不能直接使用next方法，因为他本身是个对象，可迭代的部分在对象内部的迭代器里面，想用next方法可以使用<code>instance[Symbol.iterator]().next()</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.items = []</span><br><span class="line">    &#125;</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> *<span class="keyword">this</span>.items.values()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> collection = <span class="keyword">new</span> Collection()</span><br><span class="line">collection.items.push(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> collection) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(collection[<span class="built_in">Symbol</span>.iterator]().next())</span><br><span class="line"><span class="comment">//&#123;value: 1, done: false&#125;</span></span><br><span class="line">collection <span class="comment">// Collection &#123;items:[1,2,3]&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><ul>
<li>静态成员指的是只有类本身有得属性和方法，不能实例化到实例身上</li>
<li>static不能用于定义构造函数方法，相当于重写了构造函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//es6之前定义静态成员</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line">Person.create = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例方法</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//es6静态成员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> create(name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = Person.create(<span class="string">"jimmy"</span>)</span><br><span class="line">person.sayName()<span class="comment">//jimmy</span></span><br><span class="line">person.create()<span class="comment">//TypeError</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="继承与派生类"><a href="#继承与派生类" class="headerlink" title="继承与派生类"></a>继承与派生类</h3><ul>
<li><p>继承</p>
<ul>
<li><p>ES6之前实现继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//es6之前实现继承</span></span><br><span class="line"><span class="comment">//父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length, width</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length</span><br><span class="line">    <span class="keyword">this</span>.width = width</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在父构造函数的原型链中添加getArea方法</span></span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">length, n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//借用构造函数技术，也称为经典继承或者伪构造对象技术</span></span><br><span class="line">    <span class="comment">//这里把长和宽都赋值成了长</span></span><br><span class="line">    Rectangle.call(<span class="keyword">this</span>, length, length)</span><br><span class="line">    <span class="comment">//父构造函数没有的属性</span></span><br><span class="line">    <span class="keyword">this</span>.n = n</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过将父构造函数的实例赋值在子原型上实现继承</span></span><br><span class="line"><span class="comment">//Object.create是ES5的方法，返回一个实例</span></span><br><span class="line">Square.prototype = <span class="built_in">Object</span>.create(Rectangle.prototype, &#123;</span><br><span class="line">    <span class="comment">//把子构造函数接到父构造函数的原型链上</span></span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">        value: Square,</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//可以重写getArea方法</span></span><br><span class="line">    getArea: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.length + <span class="keyword">this</span>.n</span><br><span class="line">        &#125;,</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//ES5之前，组合继承方法</span></span><br><span class="line">Square.prototype = <span class="keyword">new</span> Rectangle()</span><br><span class="line">Square.prototype.constructor = Square</span><br><span class="line">Square.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.length + <span class="keyword">this</span>.n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6增加了extends关键字和super方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length</span><br><span class="line">        <span class="keyword">this</span>.width = width</span><br><span class="line">    &#125;</span><br><span class="line">    getArea() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Square继承Rectangle</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="comment">//等价于Rectangle.call(this, length, length)</span></span><br><span class="line">        <span class="keyword">super</span>(length,length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>派生类：继承自其他类的类，子类就是父类的派生类，也可以说使用extends关键字声明的类</p>
<ul>
<li><p>派生类中如果不使用构造函数(即也没有写super())，则创建派生类实例时会自动调用super()并传入参数.</p>
</li>
<li><p>派生类中使用了构造函数，则必须使用super()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">son</span> <span class="keyword">extends</span> <span class="title">father</span> </span>&#123;</span><br><span class="line">      <span class="comment">//无构造函数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//等价于</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">son</span> <span class="keyword">extends</span> <span class="title">father</span> </span>&#123;</span><br><span class="line">      <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">          <span class="keyword">super</span>(...args)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">  - 关于super方法是注意事项</span></span><br><span class="line"><span class="string">    - 使用区域：只能在派生类的构造函数中使用</span></span><br><span class="line"><span class="string">    - 初始化this：在构造函数中访问this之前一定要调用super方法，它负责初始化this</span></span><br><span class="line"><span class="string">    - 不用super：让派生类的构造函数返回一个对象。但效果肯定就不是想要的效果了</span></span><br><span class="line"><span class="string">- 类方法遮蔽</span></span><br><span class="line"><span class="string">  - 即在派生类中重写基类的方法会覆盖并遮蔽基类方法</span></span><br><span class="line"><span class="string">  - 可以通过super.getArea()来调用基类的方法</span></span><br><span class="line"><span class="string">- 静态成员继承</span></span><br><span class="line"><span class="string">  - 用static在基类中定义的静态成员，会被继承到派生类上，仍然不能在实例中使用</span></span><br><span class="line"><span class="string">- 派生自表达式的类：即所谓的基类是传统风格的原型链和构造函数</span></span><br><span class="line"><span class="string">  - 只要表达式可以被解析为一个函数并具有[[construct]]属性和原型，就可以用extends进行派生 </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  `</span><span class="string">``</span>javascript</span><br><span class="line">  <span class="comment">//ES5风格的构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length, width</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.length = length</span><br><span class="line">      <span class="keyword">this</span>.width = width</span><br><span class="line">  &#125;</span><br><span class="line">  Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//Rectangle不是类，但具有[[construct]]和原型，所以Square可以通过extends继承它</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">      <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">          <span class="keyword">super</span>(length, length)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">  - extends强大的功能使得类可以继承自任意类型的表达式，但如果extends的表达式本身没有构造器属性，派生的类也不会有构造器属性，尝试为其创建实例会导致程序无法调用构造器属性而报错</span></span><br><span class="line"><span class="string">  `</span><span class="string">``</span>javascript</span><br><span class="line">   <span class="comment">//Rectangle是按ES5风格定义的构造函数</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">getBase</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Rectangle</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//动态确定使用哪个基类</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">getBase</span>() </span>&#123;</span><br><span class="line">       <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">           <span class="keyword">super</span>(length, length)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//升级版，创建mixin</span></span><br><span class="line">   <span class="keyword">let</span> SerializableMixin = &#123;</span><br><span class="line">       serialize() &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> AreaMixin = &#123;</span><br><span class="line">       getArea() &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//使用mixin替代传统继承方法，可以接受任意数量的mixin对象作为参数</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">...mixins</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> base = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">       <span class="built_in">Object</span>.assign(base.prototype, ...mixins)</span><br><span class="line">       <span class="keyword">return</span> base</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">mixin</span>(<span class="title">AreaMixin</span>, <span class="title">SerializableMixin</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">           <span class="keyword">super</span>()</span><br><span class="line">           <span class="keyword">this</span>.length = length</span><br><span class="line">           <span class="keyword">this</span>.width = length</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">- 内建对象的继承</span></span><br><span class="line"><span class="string">  - 通过继承的方式，创建特殊的内建对象</span></span><br><span class="line"><span class="string">    - ES5及早期版本：先通过派生类型创建this的值，再调用基类的构造函数。所以this的值先是指向MyArray实例，随后会被来自Array的其他属性所修饰</span></span><br><span class="line"><span class="string">    - ES6：先由基类创建this的值，然后派生类的构造函数再修改这个值</span></span><br><span class="line"><span class="string">  `</span><span class="string">``</span>javascript</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">MyArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//先创建this的值指向实例，再调用原生Array</span></span><br><span class="line">        <span class="built_in">Array</span>.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    MyArray.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype, &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: &#123;</span><br><span class="line">            value: MyArray</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray()</span><br><span class="line">    colors[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    colors.length <span class="comment">// 0   此时的colors是一个MyArray的实例对象&#123;0:1&#125;</span></span><br><span class="line">    colors.push(<span class="number">1</span>)</span><br><span class="line">    colors.length <span class="comment">//1   此时的colors是一个数组[1]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ES6</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Array</span>() </span>&#123;</span><br><span class="line">        <span class="comment">//内建对象的继承一般就不写构造器属性了，会自动生成</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray()</span><br><span class="line">    colors[<span class="number">0</span>] = <span class="string">"red"</span></span><br><span class="line">    colors.length <span class="comment">// 1</span></span><br><span class="line">  <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">- Symbol.species属性</span></span><br><span class="line"><span class="string">  - 原本在内建对象中会返回实例自身的方法，在内建对象继承的派生类中同样也回返回派生类的实例</span></span><br><span class="line"><span class="string">  `</span><span class="string">``</span>javascript</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> items = <span class="keyword">new</span> MyArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">  subitems = items.slice(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">  subitems <span class="keyword">instanceof</span> MyArray <span class="comment">//true</span></span><br><span class="line">  <span class="comment">//这一切是浏览器引擎通过Symbol.species属性实现的</span></span><br><span class="line">  <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">  - Symbol.species被用于定义返回函数的静态访问器属性。被返回的函数是一个构造函数。每当要在实例的方法中创建类的实例时必须使用这个构造函数</span></span><br><span class="line"><span class="string">    - 已经定义Symbol.species属性的内建类型有</span></span><br><span class="line"><span class="string">      - Array</span></span><br><span class="line"><span class="string">      - ArrayBuffer</span></span><br><span class="line"><span class="string">      - Map</span></span><br><span class="line"><span class="string">      - Promise</span></span><br><span class="line"><span class="string">      - RegExp</span></span><br><span class="line"><span class="string">      - Set</span></span><br><span class="line"><span class="string">      - Typed arrays</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    `</span><span class="string">``</span>javascript</span><br><span class="line">    <span class="comment">//如果想修改这些默认行为可以继承的时候重写静态访问器属性</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">get</span>[Symbol.species]() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Array</span></span><br><span class="line">            <span class="comment">//这样设置之后，MyArray实例的那些原本会返回自身类型的方法返回的类型都是Array了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//内建类型使用species的原理</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">            <span class="comment">//this就是构造函数，即Symbol.species总会返回构造函数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有getter没有setter是因为不可以改变类的种类</span></span><br><span class="line">        <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value</span><br><span class="line">        &#125;</span><br><span class="line">        clone() &#123;</span><br><span class="line">            <span class="comment">//this.constructor一般与[Symbol.species]连用</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor[<span class="built_in">Symbol</span>.species](<span class="keyword">this</span>.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyDerivedClass1</span> <span class="keyword">extends</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyDerivedClass2</span> <span class="keyword">extends</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可以通过这个方式来修改实例方法的返回值类型，但不会修改实例本身的类型</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">            <span class="keyword">return</span> MyClass</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> instance1 = <span class="keyword">new</span> MyDerivedClass1(<span class="string">"foo"</span>)</span><br><span class="line">    ,clone1 = instance1.clone()</span><br><span class="line">    ,instance2 = <span class="keyword">new</span> MyDerivedClass2(<span class="string">"bar"</span>)</span><br><span class="line">    ,clone2 = instance2.clone()</span><br><span class="line"></span><br><span class="line">    instance2 <span class="keyword">instanceof</span> MyDerivedClass2 <span class="comment">//true</span></span><br><span class="line">    clone <span class="keyword">instanceof</span> MyDerivedClass2 <span class="comment">//false  是MyClass类型</span></span><br><span class="line">    <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 在类的构造函数中使用new.target</span></span><br><span class="line"><span class="string">- 在类的构造函数中的new.target永远不会是undefined，因为类必须通过new调用</span></span><br><span class="line"><span class="string">- 在类的构造函数中使用new.terget来确定类是如何被调用的，一般等于类的构造函数</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle)</span><br><span class="line">        <span class="keyword">this</span>.length = length</span><br><span class="line">        <span class="keyword">this</span>.width = width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Square(<span class="number">3</span>) <span class="comment">//false 此时new.target === Square</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>创建抽象类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">new</span>.target === Shape)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Shape is a abstract class'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="keyword">this</span>.length = length</span><br><span class="line">        <span class="keyword">this</span>.width = width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Shape() <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>) </span><br><span class="line">y <span class="keyword">instanceof</span> Shape <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="10-改进的数组功能"><a href="#10-改进的数组功能" class="headerlink" title="10.改进的数组功能"></a>10.改进的数组功能</h2><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><ul>
<li><p>ES6-创建数组的方式：Array构造函数和数组字面量</p>
</li>
<li><p>ES6新增创建数组的方式：Array.of() 和 Array.from()</p>
</li>
<li><p>Array构造函数的问题</p>
<ul>
<li>当传入一个数值型参数时，该数组的length被设置为该值</li>
<li>当传入一个非数值参数或者多个参数时，传入的参数都会变成数组的元素<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>)</span><br><span class="line">items.length <span class="comment">// 1</span></span><br><span class="line">items[<span class="number">0</span>] <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">items = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'2'</span>)</span><br><span class="line">items.length <span class="comment">// 1</span></span><br><span class="line">items[<span class="number">0</span>] = <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line">items = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="string">'2'</span>)</span><br><span class="line">items.length <span class="comment">// 2</span></span><br><span class="line">items[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">items[<span class="number">1</span>] = <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line">items = <span class="keyword">new</span> <span class="built_in">Array</span>([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line">items.length <span class="comment">// 1</span></span><br><span class="line">items[<span class="number">0</span>] = [<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Array.of()</p>
<ul>
<li><p>为什么解决Array构造函数的问题，引入了Array.of()方法，该方法的参数只表示创建数组的元素。即除了只传入一个数值型参数与Array构造函数处理不同外完全相同</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> items = <span class="built_in">Array</span>.of(<span class="number">1</span>)</span><br><span class="line">items.length <span class="comment">// 1</span></span><br><span class="line">items[<span class="number">0</span>] <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>大多时候可以用数组字面量来创建原生数组，但如果创建数组是封装在一个函数中，数组的元素是作为参数被传入函数中，为了防止参数是单一数字可以使用Array.of()代替new Array()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> createArray = <span class="function"><span class="keyword">function</span>(<span class="params">arrayCreator, value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> arrayCreator(value)</span><br><span class="line">      <span class="comment">//为什么不是return [value],因为最好要保持一致性，这里就不要用字面量的表示法</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Array.of(1) [1]</span></span><br><span class="line">  <span class="comment">//new Array(1) [empty]</span></span><br><span class="line">  <span class="keyword">let</span> items = createArray(<span class="built_in">Array</span>.of, <span class="number">1</span>)</span><br><span class="line">  <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">  - Array.of()不通过Symbol.species属性确定返回值类型，使用当前构造函数来确定正确的返回类型，即谁调用of，就返回什么类型(数组和类数组)</span></span><br><span class="line"><span class="string">- Array.from()方法：接受可迭代对象或类数组对象为第一参数，最终返回一个数组</span></span><br><span class="line"><span class="string">  - 映射转换</span></span><br><span class="line"><span class="string">    - 第二个参数：映射函数</span></span><br><span class="line"><span class="string">  - 转换可迭代对象</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### ES6数组新方法</span></span><br><span class="line"><span class="string">- find()和findIndex()方法</span></span><br><span class="line"><span class="string">- fill()方法</span></span><br><span class="line"><span class="string">- copyWithin()方法</span></span><br><span class="line"><span class="string">### 定型数组</span></span><br><span class="line"><span class="string">- 数值数据类型</span></span><br><span class="line"><span class="string">- 数组缓冲区</span></span><br><span class="line"><span class="string">- 通过视图操作数组缓冲区</span></span><br><span class="line"><span class="string">### 定型数组与普通数组比较</span></span><br><span class="line"><span class="string">#### 相似之处</span></span><br><span class="line"><span class="string">#### 差别</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 11.Promise与异步编程</span></span><br><span class="line"><span class="string">### 异步编程</span></span><br><span class="line"><span class="string">- 什么是异步编程</span></span><br><span class="line"><span class="string">  - JavaScript引擎是基于单线程事件循环概念构建的</span></span><br><span class="line"><span class="string">  - 任务队列：JavaScript引擎同一时刻只能执行一个代码块，所以需要跟踪即将运行的代码，所以任务队列就是用来存储这些即将运行的代码，让他们排成一个队列，每当一段代码准备执行时，都会被添加到任务队列中，</span></span><br><span class="line"><span class="string">  - 事件循环：负责监控代码执行并管理任务队列</span></span><br><span class="line"><span class="string">  - [JavaScript 异步、栈、事件循环、任务队列](https://segmentfault.com/a/1190000011198232)</span></span><br><span class="line"><span class="string">- 事件模型</span></span><br><span class="line"><span class="string">  - 见JavaScript高级程序设计中介绍的 [事件](#13.事件)</span></span><br><span class="line"><span class="string">  - 事件模型适用于处理简单的交互，因为无法总是保证事件处理程序在事件触发之前已经加载完成( 即用户可能在onclick函数没加载完成之前就已经在疯狂点击button了)</span></span><br><span class="line"><span class="string">- 回调模式</span></span><br><span class="line"><span class="string">  - 回调模式中被调用的函数作为参数传入</span></span><br><span class="line"><span class="string">  - 问题：回调地狱难以理解和调试</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### Promise基础</span></span><br><span class="line"><span class="string">- 什么是Promise</span></span><br><span class="line"><span class="string">  - 相当于异步操作结果的占位符，它不去订阅事件，也不传递一个回调函数，而是让函数返回一个Promise</span></span><br><span class="line"><span class="string">    `</span><span class="string">``</span>javascript</span><br><span class="line">    <span class="keyword">var</span> promise = readFile(<span class="string">"helloworld.txt"</span>)</span><br><span class="line">    <span class="comment">//代码开始时，readFile()不会立即开始读取文件，首先会返回一个Promise对象表示异步读取操作</span></span><br><span class="line">    <span class="comment">//未来如何操作这个对象取决于Promise的生命周期</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Promise的生命周期</p>
<ul>
<li><p>生命周期</p>
<ul>
<li>两个状态：未处理和已处理；三个状态：进行中、成功、失败<ul>
<li>unsettled   未处理<ul>
<li>pending   进行中</li>
</ul>
</li>
<li>settled     已处理<ul>
<li>fulfilled 成功</li>
<li>rejected  失败</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>[[PromiseState]]内部属性来表示Promise的三个状态，无法访问</p>
</li>
<li><p>then()方法</p>
<ul>
<li>Promise对象通过then()方法来根据特定状态执行特定操作</li>
<li>参数<ul>
<li>第一个参数是当promise状态为fulfilled时调用的函数</li>
<li>第二个参数是当promise状态为rejected时调用的函数</li>
<li>两个参数都是可选的</li>
</ul>
</li>
<li>thenable对象<ul>
<li>一个对象实现了then方法，就可以称之为thenable对象</li>
<li>所有Promise对象都是thenable对象，反之不然</li>
</ul>
</li>
</ul>
</li>
<li><p>catch()方法</p>
<ul>
<li>和只传入拒绝处理程序的then()方法等价    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err.message)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">promise.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>每次调用then()方法或catch()方法都会创建一个新任务，当promise被解决时执行，这些任务会被加入到一个为promise量身定制的独立任务队列</p>
</li>
</ul>
</li>
<li><p>创建未完成的Promise</p>
<ul>
<li><p>用Promise构造函数创建Promise</p>
<ul>
<li><p>构造函数只接受一个参数：包含初始化Promise代码的执行器(executor)函数</p>
</li>
<li><p>执行器函数接受两个参数：resolve函数(执行器成功时调用)和reject函数(执行器失败时调用)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> exec = <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//触发异步操作</span></span><br><span class="line">        fs.readFile(filename, &#123; <span class="attr">encoding</span>: <span class="string">"utf-8"</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//检查是否有错误</span></span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//成功读取文件</span></span><br><span class="line">            resolve(contents)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(exec)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = readFile(<span class="string">"example.txt"</span>)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(contents)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise的执行器会立即执行,无论是调用了resolve还是reject，都会将一个新任务推入任务队列</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'promise'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'window'</span>)</span><br><span class="line"><span class="comment">//promise</span></span><br><span class="line"><span class="comment">//window</span></span><br><span class="line"></span><br><span class="line">setTimeOut(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//也将新任务推入了任务队列，只不过要求这个任务在500ms后执行，所以比window后显示</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimtout'</span>)</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'window'</span>)</span><br><span class="line"><span class="comment">//window</span></span><br><span class="line"><span class="comment">//setTimeout</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行函数调用resolve()或reject()后，会触发一个异步操作，传入then方法的函数此时会被添加到任务队列中，并异步执行(可以理解成resolve()是一个发射器，promise.then()的第一个参数的函数是这个发射器的接收装置，这个函数的参数就是发射器传过来的参数)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>)</span><br><span class="line">    resolve(<span class="string">'resolve'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//完成处理程序和拒绝处理程序总是在执行器完成后再被添加到任务队列的末尾</span></span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'window'</span>)</span><br><span class="line"><span class="comment">//promise</span></span><br><span class="line"><span class="comment">//window</span></span><br><span class="line"><span class="comment">//resolve</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>创建已处理的Promise</p>
<ul>
<li><p>为什么要创建已处理的Promise</p>
<ul>
<li>如果你还不知道给用Promise来表示什么值的时候，可以用new创建一个未处理的Promise</li>
<li>如果你知道要用Promise来表示什么值的时候，再大张旗鼓的new一个Promise，在Promise中加入执行器函数有点多余，所以这时候需要创建处于settled状态的Promise</li>
</ul>
</li>
<li><p>Promise.resolve()</p>
<ul>
<li>只接受一个参数并返回一个完成状态的Promise<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>)</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(content) <span class="comment">//42</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Promise.reject()</p>
<ul>
<li><p>只接受一个参数并返回已拒绝状态的Promise</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.reject(<span class="number">42</span>)</span><br><span class="line">promise.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err) <span class="comment">//42</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err) <span class="comment">//42</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果向Promise.resove()或Promise.reject()传入一个Promise对象，会直接返回这个对象，可以用此方法来判断一个对象是不是Promise对象</p>
</li>
<li><p>如果向Promise.resolve()或Promise.reject()传入一个非Promise对象的Thenable对象，会创建一个新的Promise对象(Promise.resolve:pending状态;Promise.reject:rejected状态)，并在then函数中被调用</p>
</li>
</ul>
</li>
<li><p>非Promise的Thenable对象</p>
<ul>
<li>拥有一个接受resolve和reject这两个参数的方法并且这个方法名叫then方法的普通对象就是非Promise的Thenable对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.使用Promise.resolve创建基于Thenable的已完成Promise</span></span><br><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">    then:<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        resolve(<span class="number">42</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Promise.resolve调用的是thenable.then()，返回的是一个pending状态Promise</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable)</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//此时p1是一个pending状态Promise对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(c) <span class="comment">//42</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用Promise.resolve创建基于Thenable的已拒绝Promise</span></span><br><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">    then:<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        reject(<span class="number">42</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Promise.resolve调用的是thenable.then()，返回的是一个pending状态Promise</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable)</span><br><span class="line">p1.catch(<span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c) <span class="comment">//42</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.使用Promise.reject创建基于Thenable的已拒绝Promise</span></span><br><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">    then:<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        reject(<span class="number">42</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Promise.reject会返回一个已拒绝状态的Promise对象</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.reject(thenable)</span><br><span class="line">p1.catch(<span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c) <span class="comment">//thenable对象</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.使用Promise.reject创建基于Thenable的已完成Promise</span></span><br><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">    then:<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        resolve(<span class="number">42</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Promise.reject会返回一个已拒绝状态的Promise对象</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.reject(thenable)</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//由于p1此时已经是一个已拒绝状态的Promise对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(c) <span class="comment">//UnHandlePromiseRejectionWarning</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>执行器错误</p>
<ul>
<li>如果执行器内部抛出错误，则Promise的拒绝处理程序就会自动被调用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'I am a Problem'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.message) <span class="comment">//I am a Problem</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//原因是每个执行器中都隐藏了一个try-catch语句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(ex) &#123;</span><br><span class="line">        reject(ex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="全局的Promise拒绝处理"><a href="#全局的Promise拒绝处理" class="headerlink" title="全局的Promise拒绝处理"></a>全局的Promise拒绝处理</h3><blockquote>
<p>如果在没有catch或then的拒绝处理程序的情况下拒绝一个Promise，不会提示失败信息</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected = <span class="built_in">Promise</span>.reject(<span class="number">42</span>)</span><br><span class="line"><span class="comment">// rejected此时还没有被处理，rejected此时是一个rejected状态的Promise对象</span></span><br><span class="line"><span class="comment">//但是会报UnHandlePromiseRejectionWarning</span></span><br><span class="line">rejected.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//此时rejected已经被处理</span></span><br><span class="line">    <span class="built_in">console</span>.log(err) <span class="comment">//42</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>明明已经被Promise.reject()立即拒绝的Promise(按理来说已拒绝就是处理了)，可是我们知道要等到catch来处理才能真正算上Promise已处理(就很生硬，明明已经明文reject了)，但在不用catch/then之前却很难知道已拒绝的Promise何时被处理，所以引入全局拒绝处理</p>
<ul>
<li>Node.js环境下<ul>
<li>触发process对象上的两个事件：unhandledRejection和rejectionHandled</li>
<li>触发条件是：当Promise被拒绝，且没有拒绝处理程序(catch/then)时</li>
<li>目的：是为了识别那些已经被拒绝却还没被处理过的Promise</li>
<li>unhandledRejection事件处理程序<ul>
<li>接受两个参数，第一个参数是拒绝原因(错误对象)，第二个参数是已拒绝的Promise<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected</span><br><span class="line"><span class="comment">//监听unhandledRejection事件</span></span><br><span class="line">process.on(<span class="string">'unhandledRejection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason.message == <span class="string">'error'</span>) <span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(promise == rejected) <span class="comment">//true</span></span><br><span class="line">&#125;)</span><br><span class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>rejectionhandled事件处理程序</p>
<ul>
<li>接受一个参数，已拒绝的Promise对象</li>
<li>触发：在拒绝处理程序最后被调用时触发(异步控制最后调用)，但在同步状态(即已拒绝的Promise和catch()在一个事件循环中)有拒绝处理程序时会被忽略。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected = <span class="built_in">Promise</span>.rejecte(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>))</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'rejectionHandled'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">promise</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(promise == rejected)  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    rejected.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err.message) </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//error</span></span><br><span class="line"><span class="comment">//true ，如果catch调用不在延时函数里，则不会触发rejectionHandled事件</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>实现一个Node.js环境下简单的未处理拒绝跟踪器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possiblyUnhandledRejections = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">process.on(<span class="string">'unhandledRejected'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</span><br><span class="line">    possiblyUnhandledRejections.set(promise, reason)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'rejectionHandled'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">promise</span>) </span>&#123;</span><br><span class="line">    possiblyUnhandledRejections.delete(promise)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    possiblyUnhandledRejections.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(reason.message ? reason.message : reason)</span><br><span class="line">        <span class="comment">//做一些什么来处理这些拒绝</span></span><br><span class="line">        handleRejection(reason, promise)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    possiblyUnhandledRejections.clean()</span><br><span class="line">&#125;, <span class="number">60000</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p>浏览器环境下</p>
<ul>
<li><p>通过触发两个在window对象上的事件来识别未处理的拒绝</p>
</li>
<li><p>unhandledrejection和rejectionhandled:触发条件和Node.js环境下相同</p>
<ul>
<li>值得注意的是，浏览器下的事件名和事件的差异，即事件名是不带’on’的，但window调用的事件处理程序即事件监听器是要带’on’的</li>
</ul>
</li>
<li><p>与Node.js环境下差异</p>
<ul>
<li><p>参数差异</p>
<ul>
<li>Node.js下是接受多个独立参数(reason, promise)</li>
<li>浏览器下是接受一个event对象，这个对象有以下属性<ul>
<li>type：事件名称(unhandledrejection或rejectionhandled)</li>
<li>promise：被拒绝的promise对象</li>
<li>reason：来自被拒绝的promise对象的拒绝值(即Promise.reject()或者执行器中的reject()括号中的拒绝值)</li>
</ul>
</li>
</ul>
</li>
<li><p>浏览器的两个事件都可以使用reason，而Node.js下handledRejection事件不能使用</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected</span><br><span class="line"><span class="built_in">window</span>.onunhandledrejection = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.type) <span class="comment">//unhandledrejection</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.reason.message) <span class="comment">//error</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.promise === rejected) <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onrejectionhandled = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.type) <span class="comment">//rejectionhandled</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.reason.message) <span class="comment">//error</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.promise === rejected) <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现一个简单的未处理拒绝跟踪器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possiblyUnhandledRejections = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'unhandledRejected'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    possiblyUnhandledRejections.set(event.promise, event.reason)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'rejectionHandled'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    possiblyUnhandledRejections.delete(event.promise)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    possiblyUnhandledRejections.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(reason.message ? reason.message : reason)</span><br><span class="line">        <span class="comment">//做一些什么来处理这些拒绝</span></span><br><span class="line">        handleRejection(reason, promise)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    possiblyUnhandledRejections.clean()</span><br><span class="line">&#125;, <span class="number">60000</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="串联Promise"><a href="#串联Promise" class="headerlink" title="串联Promise"></a>串联Promise</h3><ul>
<li><p>为什么能串联</p>
<ul>
<li>因为每次调用then或catch时返回一个新的Promise，只有当第一个Promise被处理后，第二个甚至更多才会被处理<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(content)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//42</span></span><br><span class="line"><span class="comment">//then2</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>捕获错误</p>
<ul>
<li>务必在Promise链的末尾留一个拒绝处理程序以确保能够正确处理所有可能发生的错误</li>
</ul>
</li>
<li><p>Promise链的返回值</p>
<ul>
<li>Promise链的一个重要特性就是可以使用return给下游的Promise传递数据</li>
</ul>
</li>
<li><p>在Promise链中返回Promise</p>
<ul>
<li>可以将Promise对象return给下一个处理程序，这个Promise对象可以在全局定义，也可以在当前处理程序内部定义</li>
</ul>
</li>
</ul>
<h3 id="响应多个Promise"><a href="#响应多个Promise" class="headerlink" title="响应多个Promise"></a>响应多个Promise</h3><ul>
<li>Promise.all()<ul>
<li>接受一个参数，返回一个Promise</li>
<li>参数是一个含有多个受监控的Promise的可迭代对象(例如，一个数组)，只有当这个可迭代对象中所有的Promise对象被处理后，返回的Promise才会被处理，只有当所有的Promise对象resolved后，然后的Promise才会resolved，并且resolved的结果会按相同的迭代方式返回；rejected就直接返回reject()的那一个，后面的就不管了了</li>
</ul>
</li>
<li>Promise.race()<ul>
<li>顾名思义race就是竞赛，接受的参数和返回值和all()方法一模一样，但是只要有一个符合要求就直接返回，不会像all()一样，resolved就要等所有的resolved，返回一个resolved的可迭代方式，race()是只要谁第一个resolved的就返回这个，rejected也同理</li>
</ul>
</li>
</ul>
<h3 id="自Promise继承"><a href="#自Promise继承" class="headerlink" title="自Promise继承"></a>自Promise继承</h3><ul>
<li>Promise与其他内建类型一样，可以作为基类派生出其他类，所以可以自定义扩展内建Promise的功能</li>
</ul>
<h3 id="基于Promise的异步任务执行"><a href="#基于Promise的异步任务执行" class="headerlink" title="基于Promise的异步任务执行"></a>基于Promise的异步任务执行</h3><ul>
<li>返回去学习第九章生成器</li>
</ul>
<h2 id="13-用模块封装代码"><a href="#13-用模块封装代码" class="headerlink" title="13.用模块封装代码"></a>13.用模块封装代码</h2><h3 id="什么是模块"><a href="#什么是模块" class="headerlink" title="什么是模块"></a>什么是模块</h3><ul>
<li>脚本：使用共享一切的脚本加载代码，即script src导入js文件，js中定义的一切都共享一个全局作用域。缺点就是命名冲突和安全问题</li>
<li>模块：是自动运行在严格模式下，且没有办法退出运行的JavaScript代码。ES6引进模块的目标就是解决作用与问题</li>
<li>模块的特性<ul>
<li>变量：不会被自动添加到全局作用域，仅在模块顶部作用域存在</li>
<li>导出：模块必须导出一些外部代码可以访问的变量或函数</li>
<li>导入：模块可以从其他模块导入绑定</li>
<li>this：在模块的顶部，this的值是undefined</li>
<li>代码注释：模块不支持HTML风格的代码注释，这是早期浏览器留下来的JavaScript特性</li>
</ul>
</li>
<li>模块和脚本的差异<ul>
<li>加载方式：src到export、import</li>
<li>变量：只能访问模块让你看到的变量<h3 id="导出的基本语法"><a href="#导出的基本语法" class="headerlink" title="导出的基本语法"></a>导出的基本语法</h3></li>
</ul>
</li>
<li><h3 id="导入的基本语法"><a href="#导入的基本语法" class="headerlink" title="导入的基本语法"></a>导入的基本语法</h3></li>
<li>绑定：导入的数据成为绑定，放在<code>{}</code>里</li>
<li>导入单个绑定</li>
<li>导入多个绑定</li>
<li>导入整个模块</li>
<li>导入绑定的一个微秒怪异之处<h3 id="导出和导入时重命名"><a href="#导出和导入时重命名" class="headerlink" title="导出和导入时重命名"></a>导出和导入时重命名</h3><h3 id="模块的默认值"><a href="#模块的默认值" class="headerlink" title="模块的默认值"></a>模块的默认值</h3></li>
<li>导出默认值</li>
<li>导入默认值<h3 id="重新导出一个绑定"><a href="#重新导出一个绑定" class="headerlink" title="重新导出一个绑定"></a>重新导出一个绑定</h3><h3 id="无绑定导入"><a href="#无绑定导入" class="headerlink" title="无绑定导入"></a>无绑定导入</h3><h3 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h3></li>
<li>在Web浏览器中使用模块</li>
<li>浏览器模块说明符解析</li>
</ul>
<h1 id="你不知道的JS"><a href="#你不知道的JS" class="headerlink" title="你不知道的JS"></a>你不知道的JS</h1><h2 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h2><h3 id="作用域是什么"><a href="#作用域是什么" class="headerlink" title="作用域是什么"></a>作用域是什么</h3><ul>
<li>作用域是一套设计良好的规则。用来存储变量，并且之后可以方便的找到这些变量。</li>
</ul>
<h4 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h4><ul>
<li>传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤<ul>
<li>分词/词法分析(tokenizing/lexing)<ul>
<li>词法化(单词化)这个过程会将字符组成的代码分解成有意义的代码块(词法单元)</li>
<li><code>var a = 1;</code>被分解成var、a、=、1、;。空格在关键的地方会被当做词法单元</li>
<li>词法分析是<em>有状态</em>的解析规则进行的(即<code>ab</code>分成<code>a</code>和<code>b</code>还是<code>ab</code>要判断语境)</li>
</ul>
</li>
<li>解析/语法分析(Parsing)<ul>
<li>这个过程将词法单元流(数组)转换成一个代表了程序语法结构的由元素逐级嵌套所组成的的树(抽象语法树,AST)。</li>
<li><code>var a = 1;</code>转换成的抽象语法树有一个叫VariableDeclaration(变量声明)的顶级节点，接下来是一个值为a叫做Identifier(标识符)的子节点，以及一个值为=叫做AssignmentExpression(赋值表达式)的子节点。AssignmentExpression有一个值为1叫做NumericLiteral(数字文字)的子节点</li>
</ul>
</li>
<li>代码生成<ul>
<li>这个过程将AST转换为可执行代码。这个过程和语言、目标平台息息相关</li>
<li>将<code>var a = 1;</code>的AST转化为一组机器指令，用来创建一个叫做a的变量(包括分配内存等)，并将一个值存储在a中</li>
</ul>
</li>
</ul>
</li>
<li>JavaScript代码片段不是提前编译的，它 <strong>就在</strong> 执行前进行编译，编译发生在代码执行前几微秒甚至更短。编译结果不能在分布式系统中进行移植<ul>
<li>JavaScript编译器会对<code>var a = 1;</code>进行编译，然后做好执行它的准备，并通常马上执行</li>
</ul>
</li>
</ul>
<h4 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h4><ul>
<li><p>引擎</p>
<ul>
<li>职责：从头到尾负责整个JavaScript程序的编译及执行过程</li>
<li>术语：LHS和RHS<ul>
<li>在使用变量时，引擎会通过这两种查找来判断变量是否被声明</li>
<li>分别表示赋值操作的左侧和右侧</li>
<li>LHS：目的是对变量进行赋值，对哪个变量赋值就对哪个变量进行LHS引用。对变量显式的赋值或者调用函数时传入实参就是LHS引用,如a = 1</li>
<li>RHS：目的是获取变量的值，获取哪个变量的值就是对哪个变量进行RHS引用。通过引用变量来获取值就是RHS引用，如console.log(a)</li>
</ul>
</li>
</ul>
</li>
<li><p>编译器</p>
<ul>
<li>职责：引擎的好朋友，负责词法分析、语法分析及代码生成等脏活累活</li>
<li>变量的赋值操作：会执行两个动作<ul>
<li>首先编译器会在当前作用域中声明一个变量(如果之前没声明过)。这会在最开始的阶段，代码执行前进行。</li>
<li>然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值</li>
</ul>
</li>
</ul>
</li>
<li><p>作用域</p>
<ul>
<li>职责：引擎的另一位好朋友，负责收集并维护所有变量(声明的标识符)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</li>
</ul>
</li>
</ul>
<h4 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h4><ul>
<li>在当前作用域种无法找到某个变量，引擎就会在外层嵌套的作用域种继续查找，直到找到该变量为止。</li>
<li>作用域链</li>
</ul>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><ul>
<li>为什么要区分LHS和RHS<ul>
<li>因为在变量没有被声明的情况下这两种查询的行为是不一样的</li>
<li>用RHS引用查看变量是否被声明时，如果没声明(整条作用域链中)则抛出异常ReferenceError(引用异常，同作用域判别失败相关)</li>
<li>用LHS引用查看变量是否被声明时，非严格模式下不会抛出异常，而且全局作用域中会创建该变量，并将其返还给引擎。严格模式下会抛出跟RHS一样的异常</li>
<li>若RHS找到了变量，但尝试对这个变量做不合理的操作，如null.getName()会抛出异常TypeError(类型异常，作用域判别成功，对判别结果的操作异常)</li>
</ul>
</li>
</ul>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><ul>
<li>作用域共有两种主要的工作模型<ul>
<li>词法作用域</li>
<li>动态作用域</li>
</ul>
</li>
</ul>
<h4 id="词法阶段"><a href="#词法阶段" class="headerlink" title="词法阶段"></a>词法阶段</h4><ul>
<li>词法作用域就是定义在词法阶段的作用域。</li>
<li>词法作用域是由你在写代码时将变量和块作用域写在哪来决定的，因此当词法分析器处理代码时会保持作用域不变(除非使用欺骗词法作用域的方法)</li>
<li>查找：作用域会在找到第一个匹配的标识符停止</li>
<li>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</li>
</ul>
<h4 id="欺骗词法"><a href="#欺骗词法" class="headerlink" title="欺骗词法"></a>欺骗词法</h4><ul>
<li>欺骗词法作用域会导致性能下降</li>
<li><code>eval</code>和<code>with</code>能实现欺骗词法的目的<ul>
<li><code>eval()</code>接受一个字符串作为参数，并将其内容视为好像在书写代就存在于这个位置的代码。eval中的声明可以在运行期修改书写期的词法作用域<ul>
<li>严格模式下，eval中的声明无法修改所在的作用域</li>
<li><code>setInterval</code>和<code>setTimeout</code>的第一个参数也可以是字符串类似于eval。不提倡</li>
<li><code>new Function</code>的最后一个参数也可以接受字符串，避免使用</li>
</ul>
</li>
</ul>
<ul>
<li><code>with</code> 通常被当做重复引用同一个对象的多个属性的快捷方式，可以不需要重复引用对象本身<ul>
<li>with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域</li>
<li>尽管with块可以将一个对象处理为词法作用域，但是这个块内部正常的var声明并不会被限制在这个块的作用域，而是被添加到with所处的作用域中</li>
</ul>
</li>
</ul>
</li>
<li>eval函数如果接受了含有一个或多个声明的代码的字符串，就会[修改]其所处的词法作用域</li>
<li>with声明实际上是根据你传递给它的对象凭空 [创建了一个全新] 的词法作用域</li>
<li>一个不推荐使用eval和with的原因是会被严格模式所影响</li>
</ul>
<h4 id="性能-1"><a href="#性能-1" class="headerlink" title="性能"></a>性能</h4><ul>
<li>引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符</li>
</ul>
<h3 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h3><h4 id="函数中的作用域"><a href="#函数中的作用域" class="headerlink" title="函数中的作用域"></a>函数中的作用域</h4><ul>
<li>属于这个函数的全部变量都可以在整个函数的范围内使用及复用</li>
</ul>
<h4 id="隐藏内部实现"><a href="#隐藏内部实现" class="headerlink" title="隐藏内部实现"></a>隐藏内部实现</h4><ul>
<li>规避冲突<ul>
<li>全局命名空间</li>
<li>模块管理</li>
</ul>
</li>
</ul>
<h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><ul>
<li>匿名和具名</li>
<li>立即执行函数表达式</li>
</ul>
<h4 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h4><ul>
<li>with</li>
<li>try/catch<ul>
<li>catch语句</li>
</ul>
</li>
<li>let</li>
<li>const</li>
</ul>
<h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><h4 id="变量声明提升和函数声明提升"><a href="#变量声明提升和函数声明提升" class="headerlink" title="变量声明提升和函数声明提升"></a>变量声明提升和函数声明提升</h4><ul>
<li>提升：变量和函数声明从它们在代码中出现的位置被移动到作用域最顶端的过程</li>
<li>只有声明本身会被提升，而赋值或其他运行逻辑会留在原地</li>
</ul>
<h4 id="编译器处理提升"><a href="#编译器处理提升" class="headerlink" title="编译器处理提升"></a>编译器处理提升</h4><ul>
<li>包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理</li>
<li>函数表达式不会提升，若在函数表达式初始化函数之前调用函数会报TypeError<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo();<span class="comment">//TypeError，此时foo不是函数，是undefined</span></span><br><span class="line">bar();<span class="comment">//ReferenceError</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h4><ul>
<li>函数声明提升优先于变量声明提升</li>
</ul>
<h3 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h3><ul>
<li>当函数可以记住并访问所在的词法作用域时，即使函数是在当前词法作用域之外执行。就产生的闭包</li>
</ul>
<h4 id="实质问题"><a href="#实质问题" class="headerlink" title="实质问题"></a>实质问题</h4><ul>
<li>闭包定义：当函数在其本身的词法作用域以外执行时，闭包就产生了</li>
<li>词法作用域的查找规则只是闭包的一部分，也是非常重要的一部分</li>
<li>几个关于闭包的说法：<ul>
<li>闭包是一个函数</li>
<li>闭包一个作用域的容器</li>
<li>闭包是一个引用，内部函数对外部作用域的引用</li>
<li>闭包是一个标准，关于如何在函数作为值按需传递的词法环境中书写代码的标准</li>
<li>总结：闭包让函数在别处被调用时可以继续访问定义时的词法作用域</li>
</ul>
</li>
<li>内部函数具有一个涵盖包含函数作用域的闭包</li>
<li>无论通过何种手段将内部函数传递到所在的此法作用于以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包</li>
<li>自执行函数没用闭包，但同闭包息息相关<ul>
<li>息息相关：IIFE是最常用来创建被封闭起来的闭包的工具</li>
<li>没用到闭包：函数并不是在其本身的词法作用域以外执行</li>
</ul>
</li>
<li>只要用了回调函数就在使用闭包</li>
</ul>
<h4 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i)</span><br><span class="line">        &#125;,i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每秒一次共输出5个6</span></span><br></pre></td></tr></table></figure>

<ul>
<li>原因：i是全局作用域中声明，延迟函数的回调会在循环结束时执行。循环结束时i=6</li>
<li>解决方案：<ul>
<li>IIFE内部换一个迭代参数</li>
<li>let i=1</li>
</ul>
</li>
</ul>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><ul>
<li><p>模块机制</p>
<ul>
<li>模块是利用闭包的代码模式中最强大的一个</li>
<li>最常见的实现模块模式的方法通常被称为 <strong>模块暴露</strong></li>
<li>模块模式的两个必要条件<ul>
<li>必须有外部的封闭函数(引入包装函数)，该函数必须至少被调用一次，每次调用都会创建一个新的模块实例</li>
<li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态</li>
</ul>
</li>
<li>一个从函数调用所返回的只有数据属性而没有闭包函数的对象并不是真正的模块<ul>
<li>说明：函数调用的返回值中没有闭包函数的对象不是模块</li>
</ul>
</li>
</ul>
</li>
<li><p>现代的模块机制</p>
<ul>
<li>基于函数的模块</li>
<li>大多数模块依赖加载器/管理器。本质上都是将这种模块定义封装进一个友好的API<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装进一个友好的API</span></span><br><span class="line"><span class="keyword">var</span> myModules = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> modules = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">get</span> = function(name)&#123;</span><br><span class="line">        <span class="keyword">return</span> modules[name]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> define = <span class="function"><span class="keyword">function</span>(<span class="params">name,deps,impl</span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;deps.length; i++)&#123;</span><br><span class="line">            deps[i] = modules[deps[i]]</span><br><span class="line">        &#125;</span><br><span class="line">        modules[name] = impl.apply(impl,deps)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="keyword">get</span>:<span class="keyword">get</span>,</span><br><span class="line">        define:define</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)()</span><br><span class="line"></span><br><span class="line">//使用友好的API定义模块</span><br><span class="line">myModules.define("bar",[],function()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span> + who;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        hello:hello</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">myModules.define(<span class="string">"foo"</span>,[<span class="string">"bar"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">bar</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hungry = <span class="string">"hippo"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">awesome</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(bar.hello(hungry).toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        awesome: awesome</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = myModules.get(<span class="string">"bar"</span>);</span><br><span class="line"><span class="keyword">var</span> foo = myModules.get(<span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar.hello(<span class="string">"hippo"</span>))</span><br><span class="line">foo.awesome()</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>未来的模块机制</p>
<ul>
<li><p>ES6中为模块增加了一级语法支持<br>  通过模块系统进行加载时，ES6会将文件当做独立的模块来处理。每个模块都可以导入其他模块或特定的API成员，同样也可以导出自己的API成员</p>
</li>
<li><p>ES6模块相比基于函数的模块更加稳定</p>
<ul>
<li>基于函数的模块无法被编译器识别，API语义只有在运行时才会被考虑。因此可以在运行时修改一个模块的API</li>
<li>ES6模块的API不会在运行时改变，编译器会在编译期间对导入模块API成员的引用检查是否真实存在，若不存在会在运行时更早的抛错</li>
</ul>
</li>
<li><p>ES6模块必须被定义在独立的文件中，即一个文件一个模块。浏览器或引擎可以在导入模块时异步的加载模块文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bar.js</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span> + who;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">export</span> hello;</span><br><span class="line"></span><br><span class="line">foo.js</span><br><span class="line">    <span class="comment">//导入bar模块中的hello函数</span></span><br><span class="line">    <span class="keyword">import</span> hello <span class="keyword">from</span> <span class="string">"bar"</span></span><br><span class="line">    <span class="keyword">var</span> hungry = <span class="string">"hippo"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">awesome</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(hello(hungry).toUpperCase())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> awesome;</span><br><span class="line"></span><br><span class="line">baz.js</span><br><span class="line">    <span class="comment">//导入完整的模块</span></span><br><span class="line">    <span class="built_in">module</span> foo form <span class="string">"foo"</span>;</span><br><span class="line">    <span class="built_in">module</span> bar form <span class="string">"bar"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(bar.hello(<span class="string">"lzm"</span>))</span><br><span class="line">    bar.awesome()</span><br></pre></td></tr></table></figure>
</li>
<li><p>import 将一个模块中的一个或多个API导入到当前作用于中，并分别绑定在一个变量上</p>
</li>
<li><p>module 将整个模块的API导入并绑定到一个变量上</p>
</li>
<li><p>export 将当前模块的一个标识符导出为公共API</p>
</li>
</ul>
</li>
</ul>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h4><ul>
<li>JavaScript不具有动态作用域</li>
<li>动态作用域与this机制</li>
<li>动态作用域的作用域链是基于调用栈的，而不是代码中的作用域嵌套</li>
<li>区别<ul>
<li>词法作用域是在定义时确定的，关注函数在何处声明</li>
<li>动态作用域是在运行时确定改的，关注函数从何调用</li>
</ul>
</li>
</ul>
<h4 id="块级作用域的替代方案"><a href="#块级作用域的替代方案" class="headerlink" title="块级作用域的替代方案"></a>块级作用域的替代方案</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a)<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)<span class="comment">//ReferenceError</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>ES6之前实现：ES3 catch</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">2</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(a)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)<span class="comment">//ReferenceError</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Traceur</p>
<ul>
<li>google维护的项目，该项目将ES6代码转换成兼容ES6之前的环境<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Traceur将ES6块作用域的代码片段转换成下列代码</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="literal">undefined</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(a)&#123;</span><br><span class="line">        a = <span class="number">2</span></span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>隐式和显式作用域</p>
<ul>
<li>let关键字隐式的创建块作用域</li>
<li>let声明会创建一个显式的作用域并进行绑定(需要使用工具let-er)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//let 声明,使用let-er工具</span></span><br><span class="line"><span class="keyword">let</span>(a=<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>性能</p>
<ul>
<li>try/catch的性能很糟糕，但正在改进</li>
<li>IIFE不是一个普适性的方案，因为它毕竟是一个函数</li>
</ul>
</li>
</ul>
<h4 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h4><ul>
<li><p>箭头函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="params">a</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>箭头函数引入了叫this词法的行为</p>
<ul>
<li>箭头函数涉及this绑定的行为和普通函数this绑定的行为不一致</li>
<li>箭头函数用当前的词法作用域覆盖了this的本来的值，而不是运行时作用域</li>
<li>箭头函数继承外层函数调用的this绑定</li>
</ul>
</li>
<li><p>箭头函数不理想</p>
<ul>
<li>混淆使用两种this</li>
<li>匿名函数不具有可读性</li>
</ul>
</li>
<li><p>用bind()代替箭头函数</p>
</li>
<li><p>箭头函数不仅仅意味着少写代码</p>
</li>
</ul>
<h2 id="this和对象原型"><a href="#this和对象原型" class="headerlink" title="this和对象原型"></a>this和对象原型</h2><h3 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h3><h4 id="为什么要用this"><a href="#为什么要用this" class="headerlink" title="为什么要用this"></a>为什么要用this</h4><ul>
<li>this提供一种更优雅的方式来隐式传递一个对象引用，使得代码更加简洁和易于复用</li>
</ul>
<h4 id="误解"><a href="#误解" class="headerlink" title="误解"></a>误解</h4><ul>
<li>this指向自身</li>
<li>this指向函数作用域<ul>
<li>this在任何情况下都不指向函数的词法作用域</li>
</ul>
</li>
</ul>
<h4 id="this到底是什么"><a href="#this到底是什么" class="headerlink" title="this到底是什么"></a>this到底是什么</h4><ul>
<li>this的绑定和函数声明的位置没有关系，只取决于函数的调用方式</li>
<li>this是函数调用时活动对象的一个属性，arguments和函数参数也是活动对象的属性</li>
</ul>
<h3 id="this全面解析"><a href="#this全面解析" class="headerlink" title="this全面解析"></a>this全面解析</h3><h4 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h4><ul>
<li>调用位置：函数被调用的位置。调用位置就在当前执行函数体内的前一个调用中。</li>
<li>调用栈：存放了为了到达当前执行位置所调用的所有函数。</li>
</ul>
<h4 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h4><ul>
<li><p>默认绑定</p>
<ul>
<li>独立函数调用，指向全局</li>
<li><strong>函数体内</strong>(而不是调用位置)在严格模式下绑定到undefined，否则绑定到全局变量</li>
</ul>
</li>
<li><p>隐式绑定</p>
<ul>
<li>函数作为对象的方法，指向对象</li>
<li>隐式丢失<ul>
<li>把对象方法赋值给另一个变量。<code>var foo = obj.bar</code></li>
<li>将对象方法作为参数传入回调函数，传递参数是一种隐式赋值。<code>doBar(obj.bar)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>显式绑定-因为可以直接指定this的绑定对象</p>
<ul>
<li><p>call()和apply()</p>
</li>
<li><p>硬绑定</p>
<ul>
<li>创建一个包裹函数</li>
<li>创建一个可以重复使用的辅助函数</li>
<li>ES5 Function.prototype.bind(this)<ul>
<li>返回一个硬编码的新函数它会把参数设置为this的上下文并调用原始函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn,obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(obj,<span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>API调用的上下文</p>
<ul>
<li>forEach的第二个可选参数，实际上是通过call/apply实现显式绑定</li>
</ul>
</li>
</ul>
</li>
<li><p>new绑定</p>
<ul>
<li>使用new来调用函数，即发生构造函数调用<ul>
<li>创建一个全新的对象<code>new Object()</code></li>
<li>将构造函数的作用域赋给新对象(为了this指向新对象)</li>
<li>执行构造函数中的代码(为这个新对象添加属性)</li>
<li>如果函数没有return，那么new函数调用会返回这个新对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><ul>
<li>new &gt; 显示 &gt; 隐式 &gt; 默认</li>
<li>判断this<ul>
<li>函数是否在new中被调用?如果是，this绑定的是新创建的对象</li>
<li>函数是否通过call/apply/bind调用？如果是，this绑定的是指定对象</li>
<li>函数是否在某个上下文对象中被调用？如果是，this绑定的是上下文对象<ul>
<li><code>obj.foo()</code>obj的作用域即是foo函数的上下文</li>
<li><code>var bar = obj.foo()</code>声明bar的作用域即是foo函数的上下文</li>
</ul>
</li>
<li>如果都不是，使用默认绑定。严格模式下，绑定到undefined，否则绑定到全局变量</li>
</ul>
</li>
</ul>
<h4 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h4><ul>
<li>被忽略的this<ul>
<li>使用null、undefined作为this绑定对象传入call、apply、bind<ul>
<li>使用foo.apply(null,array)展开数组,foo函数定义展开的方式<ul>
<li>ES6新增…操作符可以代替展开数组</li>
</ul>
</li>
<li>使用bind(null,arguments..)预设一些参数实现柯里化</li>
<li>副作用：可能修改全局对象</li>
</ul>
</li>
<li>更安全的this<ul>
<li>传入一个特殊的对象DMZ(demilitarized zone非军事区)，而不是传入null</li>
<li>var DMZ = Object.create(null)</li>
<li>create比{}创建的对象更空，因为不创建prototype</li>
</ul>
</li>
</ul>
</li>
<li>间接引用<ul>
<li>(b=a)的意思是将a赋值给b并返回b，属于LHS,若不存在b会创建b</li>
<li>默认绑定</li>
</ul>
</li>
<li>软绑定<ul>
<li>硬绑定会大大降低函数灵活性，无法再修改this</li>
<li>实现：给默认绑定指定一个全局对象和undefined以外的值</li>
</ul>
</li>
</ul>
<h4 id="重提this词法"><a href="#重提this词法" class="headerlink" title="重提this词法"></a>重提this词法</h4><ul>
<li>箭头函数不适用this的四种标准规则，而是根据外层作用域来决定this</li>
<li>箭头函数最常用回调函数，比如时间处理器或者定时器</li>
<li>ES6之前在外层作用域中<code>var that = this</code>保留外层作用域中的this</li>
<li>只使用词法作用域并完全抛弃错误this风格的代码<ul>
<li>错误this风格指的是使用<code>var that = this</code>或者箭头函数，</li>
<li>完全使用this机制和bind()</li>
</ul>
</li>
</ul>
<h3 id="对象-1"><a href="#对象-1" class="headerlink" title="对象"></a>对象</h3><h4 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h4><ul>
<li>两种定义对象形式<ul>
<li>对象字面量<code>var myObj = { key: value }</code></li>
<li>构造形式<code>var myObj = new Object()</code></li>
</ul>
</li>
</ul>
<h4 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h4><ul>
<li>数据类型<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null<ul>
<li>本身是基本类型，但typeof null //object</li>
</ul>
</li>
<li>undefined</li>
<li>object<ul>
<li>function</li>
<li>array</li>
</ul>
</li>
</ul>
</li>
<li>内置对象<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>RegEx</li>
<li>Error</li>
<li>Date</li>
</ul>
</li>
</ul>
<h4 id="对象的内容"><a href="#对象的内容" class="headerlink" title="对象的内容"></a>对象的内容</h4><ul>
<li><p>属性：对象的内容是由一些存储在特定命名位置的值组成的，称之为属性</p>
<ul>
<li>访问值两种方法<ul>
<li><code>.</code>属性访问</li>
<li><code>[]</code>键访问</li>
<li>区别：<ul>
<li>键访问可以用字符串计算确定属性名<code>[&#39;l&#39;+&#39;zm&#39;]</code>,使用非字符串会转成字符串</li>
<li>属性访问要求属性名满足标识符命名规范；键访问可以接受任意字符串</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>可计算属性名</p>
<ul>
<li>ES6增加了可计算属性名<code>{[ pro + &quot;bar&quot;]: &quot;hello&quot;}</code></li>
<li>ES6符号Symbol：一个不透明且无法预测的值<code>{[Symbol.sth] = &quot;hello&quot;]}</code></li>
</ul>
</li>
<li><p>属性与方法</p>
<ul>
<li>方法：对象的函数</li>
<li>函数永远不会只成为一个对象的属性，函数和对象的关系最多也只是间接关系</li>
<li>最保险的说法，函数和方法再JavaScript中可以互换</li>
<li>ES6新增super引用，class中有时候把super绑定的函数称为方法，语义上的差别。但本质上也是间接关系。因为函数不会属于对象，只是对于相同函数对象的多个引用</li>
</ul>
</li>
<li><p>数组</p>
<ul>
<li>数组是一套更加结构化的值存储机制，不过不限制值的类型</li>
<li>数组也是对象，可以给数组添加属性<code>array.pro = value //[&quot;pro&quot;:&quot;value&quot;]</code>但length不会加长。但是不建议使用数组当做键值对对象使用</li>
<li>如果添加的属性名可以转成数字，那么会被当做下标<code>array[&quot;4&quot;] = value //[empty,empty,empty,empty,value]</code></li>
</ul>
</li>
<li><p>复制对象</p>
<ul>
<li>浅复制<ul>
<li>新对象复制旧对象的值，新对象内部的属性和旧对象内部的属性的引用对象相同，即修改旧对象，新对象也会修改，因为引用的是同一个地址的对象</li>
<li>ES6 Object.assign()</li>
</ul>
</li>
<li>深复制<ul>
<li>新对象复制旧对象之外还复制旧对象的属性</li>
<li>实现<ul>
<li>递归浅复制，把旧对象的属性遍历复制给新对象</li>
<li>对于JSON安全的对象，即可以被序列化且可以解析的对象<br>  <code>var newObj = JSON.parse(JSON.stringify(obj))</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>属性描述符<br>  + </p>
</li>
<li><p>不变性</p>
<ul>
<li>对象常量<ul>
<li>writable：false</li>
<li>configurable：false</li>
</ul>
</li>
<li>禁止扩展<ul>
<li>Object.preventExtensions(Obj)禁止一个对象添加新属性并保留已有属性<br><code>Object.PreventExtensions(obj); obj.b = 3; obj.b//undefined</code></li>
</ul>
</li>
<li>密封<ul>
<li>Object.seal()创建一个密封的对象</li>
<li>实现：在现有对象上调用preventExtensions()并把所有属性configurable:false</li>
<li>密封之后不能修改添加新属性，也不能重新配置或delete任何属性，可以修改值</li>
</ul>
</li>
<li>冻结<ul>
<li>Object.freeze()创建一个冻结对象</li>
<li>实现：在现有对象上调用seal()并把所有属性标记为writable:false</li>
<li>冻结之后，无法修改值</li>
<li>冻结拥有最高级别的不变性</li>
</ul>
</li>
<li>上述所有方法创建的都是浅不变性，即只会影响目标对象和其直接属性，若目标对象引用其他对象，其他对象的内部不受影响，仍然可变。若需要深不变性，遍历引用的所有的对象并调用相应方法即可。很少需要深不变性</li>
</ul>
</li>
<li><p><code>[[Get]]</code></p>
<ul>
<li>对象的属性访问实际上是实现了[[Get]]操作</li>
<li>如果当前对象和原型链都没有找到相同名称的属性，会返回undefined</li>
</ul>
</li>
<li><p><code>[[Put]]</code></p>
<ul>
<li>设置属性或创建属性</li>
</ul>
</li>
<li><p>Getter和Setter</p>
<ul>
<li>都是隐藏函数，分别在获取属性值时和设置属性值时调用</li>
<li>当同时给属性定义getter和setter时，此属性会被定义为访问描述符，它们的value和writable特性会被忽略</li>
<li>两种方法配置<ul>
<li>对象字面量中<code>get a(){}</code></li>
<li>Object.defineProperty(obj,prop,{get:f,set:f})<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="keyword">get</span> a()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">'b'</span>,&#123;</span><br><span class="line">    <span class="keyword">get</span>:function()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>存在性</p>
<ul>
<li><code>prop in obj</code>检查属性是否在对象及其原型链中<ul>
<li><code>in</code>检查属性名是否存在而不是值，不能用来检查值在不在数组中</li>
</ul>
</li>
<li><code>obj.hasOwnProperty(prop)</code>检查属性是否在对象中</li>
<li><code>Object.prototype.hasOwnProperty.call(obj,prop)</code>判断存在性的强硬方法</li>
<li>可枚举<ul>
<li>可以出现在对象属性的遍历中<code>enumerable:true</code></li>
<li><code>for in</code>最好只应用在对象上</li>
<li><code>obj.propertyIsEnumberable(prop)</code>检查给定的属性名是否直接存在于对象中并满足enumerable:true</li>
<li><code>Object.keys(obj)</code>返回一个数组，包含所有可枚举属性</li>
<li><code>Object.getOwnPropertyNames(obj)</code>返回一个数组，包含所有属性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><ul>
<li>遍历属性<ul>
<li>遍历对象<ul>
<li><code>for in</code></li>
</ul>
</li>
<li>遍历数组<ul>
<li><code>for</code>遍历数组下标指向值</li>
<li>ES5数组的辅助迭代器 <code>forEach</code> <code>every</code> <code>some</code><ul>
<li>forEach忽略回调函数的返回值</li>
<li>every一直运行到回调函数返回值为false</li>
<li>some一直运行到回调函数返回值为true</li>
<li>every和some类似于for循环中的break</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>直接遍历值<ul>
<li>ES6 <code>for of</code><ul>
<li>被访问对象请求一个迭代器对象，通过调用迭代器对象的next方法遍历所有返回值</li>
<li>数组有内置的@@iterator，对象需要定义迭代器</li>
<li>@@iterator本身不是一个迭代器对象，而是一个返回迭代器对象的函数，使用时需要函数执行<code>myArr[Symbol.iterator]()</code></li>
<li><code>next()</code>返回形式<code>{value:.., done:..}</code>done表示遍历是否结束</li>
<li>每次调用迭代器对象的next()内部指针都会向前移动并返回对象属性列表的下一个值</li>
</ul>
</li>
<li>使用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> array)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//array[0]</span></span><br><span class="line"><span class="comment">//array[1]</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//使用Symbol.iterator获取对象的@@iterator内部属性</span></span><br><span class="line"><span class="keyword">var</span> it = array[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">it.next()<span class="comment">//&#123;value:array[0],done:false&#125;</span></span><br><span class="line">...</span><br><span class="line">it.next()<span class="comment">//&#123;done:true&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="混合对象“类”"><a href="#混合对象“类”" class="headerlink" title="混合对象“类”"></a>混合对象“类”</h3><h4 id="类理论"><a href="#类理论" class="headerlink" title="类理论"></a>类理论</h4><ul>
<li>类的设计模式<ul>
<li>类是一种设计模式，不是必须的编程基础</li>
</ul>
</li>
<li>JavaScript中的类<ul>
<li>JavaScript中没有类，提供了一些近似类的语法</li>
</ul>
</li>
</ul>
<h4 id="类的机制"><a href="#类的机制" class="headerlink" title="类的机制"></a>类的机制</h4><ul>
<li>建造<ul>
<li>类和实例的关系</li>
</ul>
</li>
<li>构造函数<ul>
<li>构造类实例的一个特殊类方法</li>
</ul>
</li>
</ul>
<h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><ul>
<li>多态<ul>
<li>虚拟多态，相对多态</li>
</ul>
</li>
<li>多重继承</li>
</ul>
<h4 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h4><ul>
<li>显式混入</li>
<li>隐式混入</li>
</ul>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><h3 id="行为委托"><a href="#行为委托" class="headerlink" title="行为委托"></a>行为委托</h3><h3 id="ES6中的class"><a href="#ES6中的class" class="headerlink" title="ES6中的class"></a>ES6中的class</h3><h2 id="类型和语法"><a href="#类型和语法" class="headerlink" title="类型和语法"></a>类型和语法</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><h3 id="原生函数"><a href="#原生函数" class="headerlink" title="原生函数"></a>原生函数</h3><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><h3 id="混合环境JavaScript"><a href="#混合环境JavaScript" class="headerlink" title="混合环境JavaScript"></a>混合环境JavaScript</h3><h2 id="异步和性能"><a href="#异步和性能" class="headerlink" title="异步和性能"></a>异步和性能</h2><h3 id="异步的现在和将来"><a href="#异步的现在和将来" class="headerlink" title="异步的现在和将来"></a>异步的现在和将来</h3><ul>
<li>异步编程的核心：程序中现在运行的部分和将来运行的部分之间的关系<h4 id="分块的程序"><a href="#分块的程序" class="headerlink" title="分块的程序"></a>分块的程序</h4></li>
<li>一个程序由若干个程序块组成，其中只有一个块是现在执行，剩下的都是在将来执行</li>
<li>任何时候，只要把一段代码包装成一个函数，并制定它在响应某个事件时执行，这就创建了一个在将来执行的块</li>
<li>异步机制：存在在将来执行的块的程序，这个程序就引入了异步机制</li>
<li>异步控制台：有些时候，某些浏览器的console.log()并不会把传入的内容立即输出。原因是程序中的I/O是非常低速的阻塞部分，所以浏览器在后台异步处理控制台I/O能够提高性能(我理解的这句话就是说console.log有时候会被当做异步执行)。若遇到这种情况，最好的选择是在调试器中使用断点，而不要依赖控制台输出<h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4></li>
<li>JavaScript引擎不是独立运行的，它运行在宿主环境中</li>
<li>各个环境都提供了一种机制来处理程序中多个块的执行，且执行每个块时调用JavaScript引擎，这种机制被称为事件循环</li>
<li>JavaScript引擎本身没有时间概念，他只是负责执行JavaScript代码块的环境，事件的调度由包含JavaScript引擎的环境进行<h4 id="并行线程"><a href="#并行线程" class="headerlink" title="并行线程"></a>并行线程</h4><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4></li>
<li>非交互</li>
<li>交互</li>
<li>协作<h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><h4 id="语句顺序"><a href="#语句顺序" class="headerlink" title="语句顺序"></a>语句顺序</h4></li>
</ul>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><h4 id="continuation"><a href="#continuation" class="headerlink" title="continuation"></a>continuation</h4><h4 id="顺序的大脑"><a href="#顺序的大脑" class="headerlink" title="顺序的大脑"></a>顺序的大脑</h4><ul>
<li>执行与计划</li>
<li>嵌套回调与链式回调<h4 id="信任问题"><a href="#信任问题" class="headerlink" title="信任问题"></a>信任问题</h4></li>
<li>五个回调的故事</li>
<li>不只是别人的代码<h4 id="省点回调"><a href="#省点回调" class="headerlink" title="省点回调"></a>省点回调</h4></li>
</ul>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><h4 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h4><ul>
<li>未来值</li>
<li>完成事件</li>
</ul>
<h4 id="具有then方法的鸭子类型"><a href="#具有then方法的鸭子类型" class="headerlink" title="具有then方法的鸭子类型"></a>具有then方法的鸭子类型</h4><h4 id="Promise信任问题"><a href="#Promise信任问题" class="headerlink" title="Promise信任问题"></a>Promise信任问题</h4><ul>
<li>调用过早</li>
<li>调用过晚</li>
<li>回调未调用</li>
<li>调用次数过少或过多</li>
<li>未能传递参数/环境值</li>
<li>吞掉错误或异常</li>
<li>是可信任的Promise么</li>
<li>简历信任</li>
</ul>
<h4 id="链式流"><a href="#链式流" class="headerlink" title="链式流"></a>链式流</h4><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><ul>
<li>绝望的陷阱</li>
<li>处理未捕获的情况</li>
<li>成功的坑</li>
</ul>
<h4 id="Promise模式"><a href="#Promise模式" class="headerlink" title="Promise模式"></a>Promise模式</h4><ul>
<li>Promise.all([..])</li>
<li>Promise.race([..])</li>
<li>all([..])和race([..])的变体</li>
<li>并发迭代</li>
</ul>
<h4 id="Promsie-API概述"><a href="#Promsie-API概述" class="headerlink" title="Promsie API概述"></a>Promsie API概述</h4><ul>
<li>new Promise() 构造器</li>
<li>Promise.resolve()和Promise.reject()</li>
<li>then()和catch()</li>
<li>Promise.all()和Promise.race()</li>
</ul>
<h4 id="Promise局限性"><a href="#Promise局限性" class="headerlink" title="Promise局限性"></a>Promise局限性</h4><ul>
<li>顺序错误处理</li>
<li>单一值</li>
<li>单决议</li>
<li>惯性</li>
<li>无法取消的Promise</li>
<li>Promise性能</li>
</ul>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><h4 id="打破完整运行"><a href="#打破完整运行" class="headerlink" title="打破完整运行"></a>打破完整运行</h4><ul>
<li>输入和输出</li>
<li>多个迭代器</li>
</ul>
<h4 id="生成器产生值"><a href="#生成器产生值" class="headerlink" title="生成器产生值"></a>生成器产生值</h4><ul>
<li>生产者与迭代器</li>
<li>iterable</li>
<li>生成器迭代器</li>
</ul>
<h4 id="异步迭代生成器"><a href="#异步迭代生成器" class="headerlink" title="异步迭代生成器"></a>异步迭代生成器</h4><h4 id="生成器-Promise"><a href="#生成器-Promise" class="headerlink" title="生成器+Promise"></a>生成器+Promise</h4><ul>
<li>支持Promise的Generator Runner</li>
<li>生成器中的Promise并发</li>
</ul>
<h4 id="生成器委托"><a href="#生成器委托" class="headerlink" title="生成器委托"></a>生成器委托</h4><ul>
<li>为什么用委托</li>
<li>消息委托</li>
<li>异步委托</li>
<li>递归委托</li>
</ul>
<h4 id="生成器并发"><a href="#生成器并发" class="headerlink" title="生成器并发"></a>生成器并发</h4><h4 id="形实转换程序"><a href="#形实转换程序" class="headerlink" title="形实转换程序"></a>形实转换程序</h4><h4 id="ES6之前的生成器"><a href="#ES6之前的生成器" class="headerlink" title="ES6之前的生成器"></a>ES6之前的生成器</h4><ul>
<li>手动变换</li>
<li>自动变换</li>
</ul>
<h3 id="程序性能"><a href="#程序性能" class="headerlink" title="程序性能"></a>程序性能</h3><h3 id="性能测试与调优"><a href="#性能测试与调优" class="headerlink" title="性能测试与调优"></a>性能测试与调优</h3><h3 id="asynquence库"><a href="#asynquence库" class="headerlink" title="asynquence库"></a>asynquence库</h3><h3 id="高级异步模式"><a href="#高级异步模式" class="headerlink" title="高级异步模式"></a>高级异步模式</h3><h2 id="起步上路"><a href="#起步上路" class="headerlink" title="起步上路"></a>起步上路</h2><h3 id="深入编程"><a href="#深入编程" class="headerlink" title="深入编程"></a>深入编程</h3><h3 id="深入JavaScript"><a href="#深入JavaScript" class="headerlink" title="深入JavaScript"></a>深入JavaScript</h3><h2 id="ES6及更新版本"><a href="#ES6及更新版本" class="headerlink" title="ES6及更新版本"></a>ES6及更新版本</h2><h3 id="ES的现在与未来"><a href="#ES的现在与未来" class="headerlink" title="ES的现在与未来"></a>ES的现在与未来</h3><h3 id="ES6语法"><a href="#ES6语法" class="headerlink" title="ES6语法"></a>ES6语法</h3><h3 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h3><h3 id="异步流控制"><a href="#异步流控制" class="headerlink" title="异步流控制"></a>异步流控制</h3><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h3 id="新增API"><a href="#新增API" class="headerlink" title="新增API"></a>新增API</h3><h3 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h3><h3 id="ES6之后"><a href="#ES6之后" class="headerlink" title="ES6之后"></a>ES6之后</h3>
      
    </div>

    

    
    
    

    

    
      
    
    
      <div>
        <div id="reward-container">
  <div>如果你觉得我的文章对你有帮助，你可以打赏我哦~</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">

    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.png" alt="李智猛 微信支付">
        <p>微信支付</p>
      </div>
    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript高级程序设计-第三版/" rel="tag"># JavaScript高级程序设计(第三版)</a>
          
            <a href="/tags/深入理解ES6/" rel="tag"># 深入理解ES6</a>
          
            <a href="/tags/你不知道的JavaScript/" rel="tag"># 你不知道的JavaScript</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div class="social_share">
            
            
              <div id="needsharebutton-postbottom">
                <span class="btn">
                  <i class="fa fa-share-alt" aria-hidden="true"></i>
                </span>
              </div>
            
            
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/11/ARTS-week5/" rel="next" title="week5">
                <i class="fa fa-chevron-left"></i> week5
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/14/7个提升幸福感的Js小技巧/" rel="prev" title="7个提升幸福感的Js小技巧">
                7个提升幸福感的Js小技巧 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
             <a href="/">
              <img class="site-author-image" itemprop="image" src="/images/logo.jpg" alt="李智猛">
            
              <p class="site-author-name" itemprop="name">李智猛</p>
              <div class="site-description motion-element" itemprop="description">李智猛的个人博客</div>
          </a></div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">45</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">56</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://github.com/leezhimeng919/blog" title="GitHub &rarr; https://github.com/leezhimeng919/blog" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="mailto:jimmyli0919@163.com" title="E-Mail &rarr; mailto:jimmyli0919@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://leezhimeng.com/" title="https://leezhimeng.com/">jimmy_github</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JS高程"><span class="nav-number">1.</span> <span class="nav-text">JS高程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-JavaScript简介"><span class="nav-number">1.1.</span> <span class="nav-text">1.JavaScript简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript简史"><span class="nav-number">1.1.1.</span> <span class="nav-text">JavaScript简史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript实现"><span class="nav-number">1.1.2.</span> <span class="nav-text">JavaScript实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript版本"><span class="nav-number">1.1.3.</span> <span class="nav-text">JavaScript版本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-在HTML中使用JavaScript"><span class="nav-number">1.2.</span> <span class="nav-text">2.在HTML中使用JavaScript</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#script元素"><span class="nav-number">1.2.1.</span> <span class="nav-text">script元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌入代码与外部文件"><span class="nav-number">1.2.2.</span> <span class="nav-text">嵌入代码与外部文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文档模式"><span class="nav-number">1.2.3.</span> <span class="nav-text">文档模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#noscript元素"><span class="nav-number">1.2.4.</span> <span class="nav-text">noscript元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-基础概念"><span class="nav-number">1.3.</span> <span class="nav-text">3.基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语法"><span class="nav-number">1.3.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关键字和保留字"><span class="nav-number">1.3.2.</span> <span class="nav-text">关键字和保留字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量"><span class="nav-number">1.3.3.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型"><span class="nav-number">1.3.4.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作符"><span class="nav-number">1.3.5.</span> <span class="nav-text">操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语句"><span class="nav-number">1.3.6.</span> <span class="nav-text">语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">1.3.7.</span> <span class="nav-text">函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-变量、作用域和内存问题"><span class="nav-number">1.4.</span> <span class="nav-text">4.变量、作用域和内存问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本类型和引用类型的值"><span class="nav-number">1.4.1.</span> <span class="nav-text">基本类型和引用类型的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行环境及作用域"><span class="nav-number">1.4.2.</span> <span class="nav-text">执行环境及作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾收集"><span class="nav-number">1.4.3.</span> <span class="nav-text">垃圾收集</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-引用类型"><span class="nav-number">1.5.</span> <span class="nav-text">5.引用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Object类型"><span class="nav-number">1.5.1.</span> <span class="nav-text">Object类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Array类型"><span class="nav-number">1.5.2.</span> <span class="nav-text">Array类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Date类型"><span class="nav-number">1.5.3.</span> <span class="nav-text">Date类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RegExp类型"><span class="nav-number">1.5.4.</span> <span class="nav-text">RegExp类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Function类型"><span class="nav-number">1.5.5.</span> <span class="nav-text">Function类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本包装类型"><span class="nav-number">1.5.6.</span> <span class="nav-text">基本包装类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单体内置对象"><span class="nav-number">1.5.7.</span> <span class="nav-text">单体内置对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-面向对象的程序设计"><span class="nav-number">1.6.</span> <span class="nav-text">6.面向对象的程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理解对象"><span class="nav-number">1.6.1.</span> <span class="nav-text">理解对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建对象"><span class="nav-number">1.6.2.</span> <span class="nav-text">创建对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承"><span class="nav-number">1.6.3.</span> <span class="nav-text">继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-函数表达式"><span class="nav-number">1.7.</span> <span class="nav-text">7.函数表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归"><span class="nav-number">1.7.1.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包"><span class="nav-number">1.7.2.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模仿块级作用域"><span class="nav-number">1.7.3.</span> <span class="nav-text">模仿块级作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#私有变量"><span class="nav-number">1.7.4.</span> <span class="nav-text">私有变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-BOM"><span class="nav-number">1.8.</span> <span class="nav-text">8.BOM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Window对象"><span class="nav-number">1.8.1.</span> <span class="nav-text">Window对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#location对象"><span class="nav-number">1.8.2.</span> <span class="nav-text">location对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#navigator对象"><span class="nav-number">1.8.3.</span> <span class="nav-text">navigator对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#screen对象"><span class="nav-number">1.8.4.</span> <span class="nav-text">screen对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#history对象"><span class="nav-number">1.8.5.</span> <span class="nav-text">history对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-客户端检测-检测是啥浏览器"><span class="nav-number">1.9.</span> <span class="nav-text">9.客户端检测(检测是啥浏览器)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#能力监测"><span class="nav-number">1.9.1.</span> <span class="nav-text">能力监测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#怪癖检测"><span class="nav-number">1.9.2.</span> <span class="nav-text">怪癖检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用户代理检测"><span class="nav-number">1.9.3.</span> <span class="nav-text">用户代理检测</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-DOM"><span class="nav-number">1.10.</span> <span class="nav-text">10.DOM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#节点层次"><span class="nav-number">1.10.1.</span> <span class="nav-text">节点层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM操作技术"><span class="nav-number">1.10.2.</span> <span class="nav-text">DOM操作技术</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-DOM拓展"><span class="nav-number">1.11.</span> <span class="nav-text">11.DOM拓展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#选择符API"><span class="nav-number">1.11.1.</span> <span class="nav-text">选择符API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元素遍历"><span class="nav-number">1.11.2.</span> <span class="nav-text">元素遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTML5"><span class="nav-number">1.11.3.</span> <span class="nav-text">HTML5</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#专有扩展"><span class="nav-number">1.11.4.</span> <span class="nav-text">专有扩展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-DOM2和DOM3"><span class="nav-number">1.12.</span> <span class="nav-text">12.DOM2和DOM3</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM变化"><span class="nav-number">1.12.1.</span> <span class="nav-text">DOM变化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#样式"><span class="nav-number">1.12.2.</span> <span class="nav-text">样式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#遍历"><span class="nav-number">1.12.3.</span> <span class="nav-text">遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#范围"><span class="nav-number">1.12.4.</span> <span class="nav-text">范围</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-事件"><span class="nav-number">1.13.</span> <span class="nav-text">13.事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#事件流"><span class="nav-number">1.13.1.</span> <span class="nav-text">事件流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件处理程序"><span class="nav-number">1.13.2.</span> <span class="nav-text">事件处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件对象"><span class="nav-number">1.13.3.</span> <span class="nav-text">事件对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件类型"><span class="nav-number">1.13.4.</span> <span class="nav-text">事件类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存和性能"><span class="nav-number">1.13.5.</span> <span class="nav-text">内存和性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模拟事件"><span class="nav-number">1.13.6.</span> <span class="nav-text">模拟事件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-Json"><span class="nav-number">1.14.</span> <span class="nav-text">20.Json</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语法-1"><span class="nav-number">1.14.1.</span> <span class="nav-text">语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简单值"><span class="nav-number">1.14.1.1.</span> <span class="nav-text">简单值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象"><span class="nav-number">1.14.1.2.</span> <span class="nav-text">对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组"><span class="nav-number">1.14.1.3.</span> <span class="nav-text">数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析与序列化"><span class="nav-number">1.14.2.</span> <span class="nav-text">解析与序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON对象"><span class="nav-number">1.14.2.1.</span> <span class="nav-text">JSON对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#序列化选项"><span class="nav-number">1.14.2.2.</span> <span class="nav-text">序列化选项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-Ajax与Comet"><span class="nav-number">1.15.</span> <span class="nav-text">21.Ajax与Comet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#XMLHttpRequest对象"><span class="nav-number">1.15.1.</span> <span class="nav-text">XMLHttpRequest对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XMLHttpRequest-2级"><span class="nav-number">1.15.2.</span> <span class="nav-text">XMLHttpRequest 2级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进度事件"><span class="nav-number">1.15.3.</span> <span class="nav-text">进度事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#跨域资源共享"><span class="nav-number">1.15.4.</span> <span class="nav-text">跨域资源共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#防篡改对象"><span class="nav-number">1.15.5.</span> <span class="nav-text">防篡改对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高级定时器"><span class="nav-number">1.15.6.</span> <span class="nav-text">高级定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义事件"><span class="nav-number">1.15.7.</span> <span class="nav-text">自定义事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拖放"><span class="nav-number">1.15.8.</span> <span class="nav-text">拖放</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-离线应用与客户端存储"><span class="nav-number">1.16.</span> <span class="nav-text">23.离线应用与客户端存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#离线监测"><span class="nav-number">1.16.1.</span> <span class="nav-text">离线监测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用缓存"><span class="nav-number">1.16.2.</span> <span class="nav-text">应用缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据存储"><span class="nav-number">1.16.3.</span> <span class="nav-text">数据存储</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-最佳实践"><span class="nav-number">1.17.</span> <span class="nav-text">24.最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#可维护性"><span class="nav-number">1.17.1.</span> <span class="nav-text">可维护性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#性能"><span class="nav-number">1.17.2.</span> <span class="nav-text">性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#部署"><span class="nav-number">1.17.3.</span> <span class="nav-text">部署</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ES6"><span class="nav-number">2.</span> <span class="nav-text">ES6</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Symbol和Symbol属性"><span class="nav-number">2.1.</span> <span class="nav-text">Symbol和Symbol属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建Symbol"><span class="nav-number">2.1.1.</span> <span class="nav-text">创建Symbol</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Symbol的使用方法"><span class="nav-number">2.1.2.</span> <span class="nav-text">Symbol的使用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Symbol共享体系"><span class="nav-number">2.1.3.</span> <span class="nav-text">Symbol共享体系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Symbol与类型强制转换"><span class="nav-number">2.1.4.</span> <span class="nav-text">Symbol与类型强制转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Symbol属性检索"><span class="nav-number">2.1.5.</span> <span class="nav-text">Symbol属性检索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过"><span class="nav-number">2.1.6.</span> <span class="nav-text">通过</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-Set集合和Map集合"><span class="nav-number">2.2.</span> <span class="nav-text">7.Set集合和Map集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ES5中的Set集合和Map集合"><span class="nav-number">2.2.1.</span> <span class="nav-text">ES5中的Set集合和Map集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可迭代对象和for-of循环"><span class="nav-number">2.2.2.</span> <span class="nav-text">可迭代对象和for-of循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内建迭代器"><span class="nav-number">2.2.3.</span> <span class="nav-text">内建迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#展开运算符与非数组可迭代对象"><span class="nav-number">2.2.4.</span> <span class="nav-text">展开运算符与非数组可迭代对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高级迭代器功能"><span class="nav-number">2.2.5.</span> <span class="nav-text">高级迭代器功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-JavaScript中的类"><span class="nav-number">2.3.</span> <span class="nav-text">9.JavaScript中的类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ES5中的近类结构"><span class="nav-number">2.3.1.</span> <span class="nav-text">ES5中的近类结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的声明"><span class="nav-number">2.3.2.</span> <span class="nav-text">类的声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类表达式"><span class="nav-number">2.3.3.</span> <span class="nav-text">类表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作为一等公民的类"><span class="nav-number">2.3.4.</span> <span class="nav-text">作为一等公民的类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问器属性"><span class="nav-number">2.3.5.</span> <span class="nav-text">访问器属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可计算成员名称"><span class="nav-number">2.3.6.</span> <span class="nav-text">可计算成员名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成器方法"><span class="nav-number">2.3.7.</span> <span class="nav-text">生成器方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态成员"><span class="nav-number">2.3.8.</span> <span class="nav-text">静态成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承与派生类"><span class="nav-number">2.3.9.</span> <span class="nav-text">继承与派生类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-改进的数组功能"><span class="nav-number">2.4.</span> <span class="nav-text">10.改进的数组功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建数组"><span class="nav-number">2.4.1.</span> <span class="nav-text">创建数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全局的Promise拒绝处理"><span class="nav-number">2.4.2.</span> <span class="nav-text">全局的Promise拒绝处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#串联Promise"><span class="nav-number">2.4.3.</span> <span class="nav-text">串联Promise</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#响应多个Promise"><span class="nav-number">2.4.4.</span> <span class="nav-text">响应多个Promise</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自Promise继承"><span class="nav-number">2.4.5.</span> <span class="nav-text">自Promise继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于Promise的异步任务执行"><span class="nav-number">2.4.6.</span> <span class="nav-text">基于Promise的异步任务执行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-用模块封装代码"><span class="nav-number">2.5.</span> <span class="nav-text">13.用模块封装代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是模块"><span class="nav-number">2.5.1.</span> <span class="nav-text">什么是模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#导出的基本语法"><span class="nav-number">2.5.2.</span> <span class="nav-text">导出的基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#导入的基本语法"><span class="nav-number">2.5.3.</span> <span class="nav-text">导入的基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#导出和导入时重命名"><span class="nav-number">2.5.4.</span> <span class="nav-text">导出和导入时重命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块的默认值"><span class="nav-number">2.5.5.</span> <span class="nav-text">模块的默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重新导出一个绑定"><span class="nav-number">2.5.6.</span> <span class="nav-text">重新导出一个绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无绑定导入"><span class="nav-number">2.5.7.</span> <span class="nav-text">无绑定导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加载模块"><span class="nav-number">2.5.8.</span> <span class="nav-text">加载模块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#你不知道的JS"><span class="nav-number">3.</span> <span class="nav-text">你不知道的JS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#作用域和闭包"><span class="nav-number">3.1.</span> <span class="nav-text">作用域和闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域是什么"><span class="nav-number">3.1.1.</span> <span class="nav-text">作用域是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#编译原理"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">编译原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#理解作用域"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">理解作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#作用域嵌套"><span class="nav-number">3.1.1.3.</span> <span class="nav-text">作用域嵌套</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异常"><span class="nav-number">3.1.1.4.</span> <span class="nav-text">异常</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#词法作用域"><span class="nav-number">3.1.2.</span> <span class="nav-text">词法作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#词法阶段"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">词法阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#欺骗词法"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">欺骗词法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#性能-1"><span class="nav-number">3.1.2.3.</span> <span class="nav-text">性能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数作用域和块作用域"><span class="nav-number">3.1.3.</span> <span class="nav-text">函数作用域和块作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数中的作用域"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">函数中的作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#隐藏内部实现"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">隐藏内部实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数作用域"><span class="nav-number">3.1.3.3.</span> <span class="nav-text">函数作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#块作用域"><span class="nav-number">3.1.3.4.</span> <span class="nav-text">块作用域</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#提升"><span class="nav-number">3.1.4.</span> <span class="nav-text">提升</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#变量声明提升和函数声明提升"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">变量声明提升和函数声明提升</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编译器处理提升"><span class="nav-number">3.1.4.2.</span> <span class="nav-text">编译器处理提升</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数优先"><span class="nav-number">3.1.4.3.</span> <span class="nav-text">函数优先</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域闭包"><span class="nav-number">3.1.5.</span> <span class="nav-text">作用域闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实质问题"><span class="nav-number">3.1.5.1.</span> <span class="nav-text">实质问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#循环和闭包"><span class="nav-number">3.1.5.2.</span> <span class="nav-text">循环和闭包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模块"><span class="nav-number">3.1.5.3.</span> <span class="nav-text">模块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#附录"><span class="nav-number">3.1.6.</span> <span class="nav-text">附录</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态作用域"><span class="nav-number">3.1.6.1.</span> <span class="nav-text">动态作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#块级作用域的替代方案"><span class="nav-number">3.1.6.2.</span> <span class="nav-text">块级作用域的替代方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this词法"><span class="nav-number">3.1.6.3.</span> <span class="nav-text">this词法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this和对象原型"><span class="nav-number">3.2.</span> <span class="nav-text">this和对象原型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关于this"><span class="nav-number">3.2.1.</span> <span class="nav-text">关于this</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么要用this"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">为什么要用this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#误解"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">误解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this到底是什么"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">this到底是什么</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this全面解析"><span class="nav-number">3.2.2.</span> <span class="nav-text">this全面解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#调用位置"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">调用位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#绑定规则"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">绑定规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优先级"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#绑定例外"><span class="nav-number">3.2.2.4.</span> <span class="nav-text">绑定例外</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重提this词法"><span class="nav-number">3.2.2.5.</span> <span class="nav-text">重提this词法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象-1"><span class="nav-number">3.2.3.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象语法"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">对象语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象类型"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">对象类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象的内容"><span class="nav-number">3.2.3.3.</span> <span class="nav-text">对象的内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#遍历-1"><span class="nav-number">3.2.3.4.</span> <span class="nav-text">遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#混合对象“类”"><span class="nav-number">3.2.4.</span> <span class="nav-text">混合对象“类”</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类理论"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">类理论</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类的机制"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">类的机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类的继承"><span class="nav-number">3.2.4.3.</span> <span class="nav-text">类的继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#混入"><span class="nav-number">3.2.4.4.</span> <span class="nav-text">混入</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型"><span class="nav-number">3.2.5.</span> <span class="nav-text">原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#行为委托"><span class="nav-number">3.2.6.</span> <span class="nav-text">行为委托</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6中的class"><span class="nav-number">3.2.7.</span> <span class="nav-text">ES6中的class</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型和语法"><span class="nav-number">3.3.</span> <span class="nav-text">类型和语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类型"><span class="nav-number">3.3.1.</span> <span class="nav-text">类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#值"><span class="nav-number">3.3.2.</span> <span class="nav-text">值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原生函数"><span class="nav-number">3.3.3.</span> <span class="nav-text">原生函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#强制类型转换"><span class="nav-number">3.3.4.</span> <span class="nav-text">强制类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语法-2"><span class="nav-number">3.3.5.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#混合环境JavaScript"><span class="nav-number">3.3.6.</span> <span class="nav-text">混合环境JavaScript</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异步和性能"><span class="nav-number">3.4.</span> <span class="nav-text">异步和性能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#异步的现在和将来"><span class="nav-number">3.4.1.</span> <span class="nav-text">异步的现在和将来</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分块的程序"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">分块的程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事件循环"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">事件循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并行线程"><span class="nav-number">3.4.1.3.</span> <span class="nav-text">并行线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并发"><span class="nav-number">3.4.1.4.</span> <span class="nav-text">并发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#任务"><span class="nav-number">3.4.1.5.</span> <span class="nav-text">任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#语句顺序"><span class="nav-number">3.4.1.6.</span> <span class="nav-text">语句顺序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回调"><span class="nav-number">3.4.2.</span> <span class="nav-text">回调</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#continuation"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">continuation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#顺序的大脑"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">顺序的大脑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信任问题"><span class="nav-number">3.4.2.3.</span> <span class="nav-text">信任问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#省点回调"><span class="nav-number">3.4.2.4.</span> <span class="nav-text">省点回调</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise"><span class="nav-number">3.4.3.</span> <span class="nav-text">Promise</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是Promise"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">什么是Promise</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#具有then方法的鸭子类型"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">具有then方法的鸭子类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise信任问题"><span class="nav-number">3.4.3.3.</span> <span class="nav-text">Promise信任问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链式流"><span class="nav-number">3.4.3.4.</span> <span class="nav-text">链式流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#错误处理"><span class="nav-number">3.4.3.5.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise模式"><span class="nav-number">3.4.3.6.</span> <span class="nav-text">Promise模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promsie-API概述"><span class="nav-number">3.4.3.7.</span> <span class="nav-text">Promsie API概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise局限性"><span class="nav-number">3.4.3.8.</span> <span class="nav-text">Promise局限性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成器"><span class="nav-number">3.4.4.</span> <span class="nav-text">生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#打破完整运行"><span class="nav-number">3.4.4.1.</span> <span class="nav-text">打破完整运行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生成器产生值"><span class="nav-number">3.4.4.2.</span> <span class="nav-text">生成器产生值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异步迭代生成器"><span class="nav-number">3.4.4.3.</span> <span class="nav-text">异步迭代生成器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生成器-Promise"><span class="nav-number">3.4.4.4.</span> <span class="nav-text">生成器+Promise</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生成器委托"><span class="nav-number">3.4.4.5.</span> <span class="nav-text">生成器委托</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生成器并发"><span class="nav-number">3.4.4.6.</span> <span class="nav-text">生成器并发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#形实转换程序"><span class="nav-number">3.4.4.7.</span> <span class="nav-text">形实转换程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6之前的生成器"><span class="nav-number">3.4.4.8.</span> <span class="nav-text">ES6之前的生成器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序性能"><span class="nav-number">3.4.5.</span> <span class="nav-text">程序性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#性能测试与调优"><span class="nav-number">3.4.6.</span> <span class="nav-text">性能测试与调优</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#asynquence库"><span class="nav-number">3.4.7.</span> <span class="nav-text">asynquence库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高级异步模式"><span class="nav-number">3.4.8.</span> <span class="nav-text">高级异步模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#起步上路"><span class="nav-number">3.5.</span> <span class="nav-text">起步上路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#深入编程"><span class="nav-number">3.5.1.</span> <span class="nav-text">深入编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深入JavaScript"><span class="nav-number">3.5.2.</span> <span class="nav-text">深入JavaScript</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6及更新版本"><span class="nav-number">3.6.</span> <span class="nav-text">ES6及更新版本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ES的现在与未来"><span class="nav-number">3.6.1.</span> <span class="nav-text">ES的现在与未来</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6语法"><span class="nav-number">3.6.2.</span> <span class="nav-text">ES6语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码组织"><span class="nav-number">3.6.3.</span> <span class="nav-text">代码组织</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步流控制"><span class="nav-number">3.6.4.</span> <span class="nav-text">异步流控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合"><span class="nav-number">3.6.5.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新增API"><span class="nav-number">3.6.6.</span> <span class="nav-text">新增API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元编程"><span class="nav-number">3.6.7.</span> <span class="nav-text">元编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6之后"><span class="nav-number">3.6.8.</span> <span class="nav-text">ES6之后</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lzm</span>

  

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.1"></script>



  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  
  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>
  <script>
    
      pbOptions = {};
      
        pbOptions.iconStyle = "box";
      
        pbOptions.boxForm = "horizontal";
      
        pbOptions.position = "bottomCenter";
      
        pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
        flOptions.iconStyle = "box";
      
        flOptions.boxForm = "horizontal";
      
        flOptions.position = "middleRight";
      
        flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>


  

  

  

  

  

  

</body>
</html>
